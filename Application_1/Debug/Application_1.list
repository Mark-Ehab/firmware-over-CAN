
Application_1.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   0000010c  08008000  08008000  00008000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00001e88  0800810c  0800810c  0000810c  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00000030  08009f94  08009f94  00009f94  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08009fc4  08009fc4  0001000c  2**0
                  CONTENTS
  4 .ARM          00000000  08009fc4  08009fc4  0001000c  2**0
                  CONTENTS
  5 .preinit_array 00000000  08009fc4  08009fc4  0001000c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000004  08009fc4  08009fc4  00009fc4  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000004  08009fc8  08009fc8  00009fc8  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         0000000c  20000000  08009fcc  00010000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          00000070  2000000c  08009fd8  0001000c  2**2
                  ALLOC
 10 ._user_heap_stack 00000604  2000007c  08009fd8  0001007c  2**0
                  ALLOC
 11 .ARM.attributes 00000029  00000000  00000000  0001000c  2**0
                  CONTENTS, READONLY
 12 .debug_info   000051cd  00000000  00000000  00010035  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_abbrev 000012c2  00000000  00000000  00015202  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_aranges 00000658  00000000  00000000  000164c8  2**3
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00000590  00000000  00000000  00016b20  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_macro  000164a6  00000000  00000000  000170b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_line   00004823  00000000  00000000  0002d556  2**0
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_str    00080687  00000000  00000000  00031d79  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .comment      0000007b  00000000  00000000  000b2400  2**0
                  CONTENTS, READONLY
 20 .debug_frame  00001730  00000000  00000000  000b247c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

0800810c <__do_global_dtors_aux>:
 800810c:	b510      	push	{r4, lr}
 800810e:	4c05      	ldr	r4, [pc, #20]	; (8008124 <__do_global_dtors_aux+0x18>)
 8008110:	7823      	ldrb	r3, [r4, #0]
 8008112:	b933      	cbnz	r3, 8008122 <__do_global_dtors_aux+0x16>
 8008114:	4b04      	ldr	r3, [pc, #16]	; (8008128 <__do_global_dtors_aux+0x1c>)
 8008116:	b113      	cbz	r3, 800811e <__do_global_dtors_aux+0x12>
 8008118:	4804      	ldr	r0, [pc, #16]	; (800812c <__do_global_dtors_aux+0x20>)
 800811a:	f3af 8000 	nop.w
 800811e:	2301      	movs	r3, #1
 8008120:	7023      	strb	r3, [r4, #0]
 8008122:	bd10      	pop	{r4, pc}
 8008124:	2000000c 	.word	0x2000000c
 8008128:	00000000 	.word	0x00000000
 800812c:	08009f7c 	.word	0x08009f7c

08008130 <frame_dummy>:
 8008130:	b508      	push	{r3, lr}
 8008132:	4b03      	ldr	r3, [pc, #12]	; (8008140 <frame_dummy+0x10>)
 8008134:	b11b      	cbz	r3, 800813e <frame_dummy+0xe>
 8008136:	4903      	ldr	r1, [pc, #12]	; (8008144 <frame_dummy+0x14>)
 8008138:	4803      	ldr	r0, [pc, #12]	; (8008148 <frame_dummy+0x18>)
 800813a:	f3af 8000 	nop.w
 800813e:	bd08      	pop	{r3, pc}
 8008140:	00000000 	.word	0x00000000
 8008144:	20000010 	.word	0x20000010
 8008148:	08009f7c 	.word	0x08009f7c

0800814c <CLCD_Init>:
/* @Return		 : void                                          				  */
/*--------------------------------------------------------------------------------*/
/* @Description	 : Initialize Character LCD								          */
/*--------------------------------------------------------------------------------*/
void CLCD_Init(void)
{
 800814c:	b580      	push	{r7, lr}
 800814e:	af00      	add	r7, sp, #0
	/* Set the direction of control pins */
	GPIO_SetPinMode(CLCD_CTRL_PINS_PORT,CLCD_E_PIN,GPIO_PIN_OUTPUT_SPEED_2MHZ_PUSHPULL);
 8008150:	2202      	movs	r2, #2
 8008152:	2108      	movs	r1, #8
 8008154:	2000      	movs	r0, #0
 8008156:	f000 fa15 	bl	8008584 <GPIO_SetPinMode>
	GPIO_SetPinMode(CLCD_CTRL_PINS_PORT,CLCD_RS_PIN,GPIO_PIN_OUTPUT_SPEED_2MHZ_PUSHPULL);
 800815a:	2202      	movs	r2, #2
 800815c:	2109      	movs	r1, #9
 800815e:	2000      	movs	r0, #0
 8008160:	f000 fa10 	bl	8008584 <GPIO_SetPinMode>

	/* Check Selected CLCD Mode */
	#if CLCD_MODE == FOUR_BIT_MODE

		/* Set the direction of data pins */
		GPIO_SetPinMode(CLCD_DATA_PORT,CLCD_D4_PIN,GPIO_PIN_OUTPUT_SPEED_2MHZ_PUSHPULL);
 8008164:	2202      	movs	r2, #2
 8008166:	210f      	movs	r1, #15
 8008168:	2001      	movs	r0, #1
 800816a:	f000 fa0b 	bl	8008584 <GPIO_SetPinMode>
		GPIO_SetPinMode(CLCD_DATA_PORT,CLCD_D5_PIN,GPIO_PIN_OUTPUT_SPEED_2MHZ_PUSHPULL);
 800816e:	2202      	movs	r2, #2
 8008170:	210e      	movs	r1, #14
 8008172:	2001      	movs	r0, #1
 8008174:	f000 fa06 	bl	8008584 <GPIO_SetPinMode>
		GPIO_SetPinMode(CLCD_DATA_PORT,CLCD_D6_PIN,GPIO_PIN_OUTPUT_SPEED_2MHZ_PUSHPULL);
 8008178:	2202      	movs	r2, #2
 800817a:	210d      	movs	r1, #13
 800817c:	2001      	movs	r0, #1
 800817e:	f000 fa01 	bl	8008584 <GPIO_SetPinMode>
		GPIO_SetPinMode(CLCD_DATA_PORT,CLCD_D7_PIN,GPIO_PIN_OUTPUT_SPEED_2MHZ_PUSHPULL);
 8008182:	2202      	movs	r2, #2
 8008184:	210c      	movs	r1, #12
 8008186:	2001      	movs	r0, #1
 8008188:	f000 f9fc 	bl	8008584 <GPIO_SetPinMode>

		/* Delay for 40 ms */
		SERV_Delay_ms(40);
 800818c:	2028      	movs	r0, #40	; 0x28
 800818e:	f000 fb9f 	bl	80088d0 <SERV_Delay_ms>

		/* Set up CLCD on the 4-bit mode */
		CLCD_SetFourBitMode();
 8008192:	f000 f97f 	bl	8008494 <CLCD_SetFourBitMode>
		#error "Wrong CLCD Mode Configuration"

	#endif

	/* Delay for 1 ms */
	SERV_Delay_ms(1);
 8008196:	2001      	movs	r0, #1
 8008198:	f000 fb9a 	bl	80088d0 <SERV_Delay_ms>

	/* Display on CLCD and turn off cursor */
	CLCD_DisplayOnCursorOff();
 800819c:	f000 f981 	bl	80084a2 <CLCD_DisplayOnCursorOff>

	/* Delay for 1 ms */
	SERV_Delay_ms(1);
 80081a0:	2001      	movs	r0, #1
 80081a2:	f000 fb95 	bl	80088d0 <SERV_Delay_ms>

	/* Clear CLCD */
	CLCD_ClearDisplay();
 80081a6:	f000 f98a 	bl	80084be <CLCD_ClearDisplay>

	/* Delay for 3 ms */
	SERV_Delay_ms(3);
 80081aa:	2003      	movs	r0, #3
 80081ac:	f000 fb90 	bl	80088d0 <SERV_Delay_ms>

	/* Setting up CLCD on entry mode */
	CLCD_SetEntryMode();
 80081b0:	f000 f98c 	bl	80084cc <CLCD_SetEntryMode>

	/* Delay for 1 ms */
	SERV_Delay_ms(1);
 80081b4:	2001      	movs	r0, #1
 80081b6:	f000 fb8b 	bl	80088d0 <SERV_Delay_ms>
}
 80081ba:	bf00      	nop
 80081bc:	bd80      	pop	{r7, pc}

080081be <CLCD_SendCommand>:
/* @Return		 : ERROR_STATUS_t                                          		  */
/*--------------------------------------------------------------------------------*/
/* @Description	 : Send a command to Character LCD controller	                  */
/*--------------------------------------------------------------------------------*/
ERROR_STATUS_t CLCD_SendCommand(uint8_t Copy_Command)
{
 80081be:	b580      	push	{r7, lr}
 80081c0:	b086      	sub	sp, #24
 80081c2:	af00      	add	r7, sp, #0
 80081c4:	4603      	mov	r3, r0
 80081c6:	71fb      	strb	r3, [r7, #7]
	/* Local Variables Definitions */
	ERROR_STATUS_t Local_Status = RT_OK ;
 80081c8:	2300      	movs	r3, #0
 80081ca:	75fb      	strb	r3, [r7, #23]
	uint8_t Local_Bit0 , Local_Bit1 , Local_Bit2 , Local_Bit3 , Local_Bit4 , Local_Bit5 , Local_Bit6 , Local_Bit7;

	/* Check if passed command is valid or not */
	if(Copy_Command == CLCD_FUNCTION_SET_EIGHT_BIT_MODE_CMD || Copy_Command == CLCD_FUNCTION_SET_FOUR_BIT_MODE_CMD  ||
 80081cc:	79fb      	ldrb	r3, [r7, #7]
 80081ce:	2b38      	cmp	r3, #56	; 0x38
 80081d0:	d02a      	beq.n	8008228 <CLCD_SendCommand+0x6a>
 80081d2:	79fb      	ldrb	r3, [r7, #7]
 80081d4:	2b28      	cmp	r3, #40	; 0x28
 80081d6:	d027      	beq.n	8008228 <CLCD_SendCommand+0x6a>
 80081d8:	79fb      	ldrb	r3, [r7, #7]
 80081da:	2b0c      	cmp	r3, #12
 80081dc:	d024      	beq.n	8008228 <CLCD_SendCommand+0x6a>
       Copy_Command == CLCD_DISPLAY_ON_CURSOR_OFF_CMD   	|| Copy_Command == CLCD_DISPLAY_OFF_CURSOR_OFF_CMD    	||
 80081de:	79fb      	ldrb	r3, [r7, #7]
 80081e0:	2b08      	cmp	r3, #8
 80081e2:	d021      	beq.n	8008228 <CLCD_SendCommand+0x6a>
 80081e4:	79fb      	ldrb	r3, [r7, #7]
 80081e6:	2b0e      	cmp	r3, #14
 80081e8:	d01e      	beq.n	8008228 <CLCD_SendCommand+0x6a>
       Copy_Command == CLCD_DISPLAY_ON_CURSOR_ON_CMD   	    || Copy_Command == CLCD_DISPLAY_OFF_CURSOR_ON_CMD    	||
 80081ea:	79fb      	ldrb	r3, [r7, #7]
 80081ec:	2b0a      	cmp	r3, #10
 80081ee:	d01b      	beq.n	8008228 <CLCD_SendCommand+0x6a>
 80081f0:	79fb      	ldrb	r3, [r7, #7]
 80081f2:	2b0f      	cmp	r3, #15
 80081f4:	d018      	beq.n	8008228 <CLCD_SendCommand+0x6a>
	   Copy_Command == CLCD_BLINK_CURSOR_CMD				|| Copy_Command == CLCD_SHIFT_LEFT_CURSOR_CMD			||
 80081f6:	79fb      	ldrb	r3, [r7, #7]
 80081f8:	2b10      	cmp	r3, #16
 80081fa:	d015      	beq.n	8008228 <CLCD_SendCommand+0x6a>
 80081fc:	79fb      	ldrb	r3, [r7, #7]
 80081fe:	2b14      	cmp	r3, #20
 8008200:	d012      	beq.n	8008228 <CLCD_SendCommand+0x6a>
	   Copy_Command == CLCD_SHIFT_RIGHT_CURSOR_CMD			|| Copy_Command == CLCD_SHIFT_LEFT_DISPLAY_CMD			||
 8008202:	79fb      	ldrb	r3, [r7, #7]
 8008204:	2b18      	cmp	r3, #24
 8008206:	d00f      	beq.n	8008228 <CLCD_SendCommand+0x6a>
 8008208:	79fb      	ldrb	r3, [r7, #7]
 800820a:	2b1c      	cmp	r3, #28
 800820c:	d00c      	beq.n	8008228 <CLCD_SendCommand+0x6a>
       Copy_Command == CLCD_SHIFT_RIGHT_DISPLAY_CMD		    || Copy_Command == CLCD_BEGIN_AT_FIRST_LINE_CMD		    ||
 800820e:	79fb      	ldrb	r3, [r7, #7]
 8008210:	2b80      	cmp	r3, #128	; 0x80
 8008212:	d009      	beq.n	8008228 <CLCD_SendCommand+0x6a>
 8008214:	79fb      	ldrb	r3, [r7, #7]
 8008216:	2bc0      	cmp	r3, #192	; 0xc0
 8008218:	d006      	beq.n	8008228 <CLCD_SendCommand+0x6a>
       Copy_Command == CLCD_BEGIN_AT_SECOND_LINE_CMD		|| Copy_Command == CLCD_DISPLAY_CLEAR_CMD 				||
 800821a:	79fb      	ldrb	r3, [r7, #7]
 800821c:	2b01      	cmp	r3, #1
 800821e:	d003      	beq.n	8008228 <CLCD_SendCommand+0x6a>
 8008220:	79fb      	ldrb	r3, [r7, #7]
 8008222:	2b06      	cmp	r3, #6
 8008224:	f040 8092 	bne.w	800834c <CLCD_SendCommand+0x18e>
       Copy_Command == CLCD_ENTRY_MODE_CMD)
	{
		/* Set RS to LOW to tell CLCD to receive a command */
		GPIO_SetPinVal(CLCD_CTRL_PINS_PORT , CLCD_RS_PIN , GPIO_PIN_LOW);
 8008228:	2200      	movs	r2, #0
 800822a:	2109      	movs	r1, #9
 800822c:	2000      	movs	r0, #0
 800822e:	f000 fa97 	bl	8008760 <GPIO_SetPinVal>

		/* Delay for 1 ms */
		SERV_Delay_ms(1);
 8008232:	2001      	movs	r0, #1
 8008234:	f000 fb4c 	bl	80088d0 <SERV_Delay_ms>

		/* Set E to LOW tell CLCD to stop reading the command */
		GPIO_SetPinVal(CLCD_CTRL_PINS_PORT , CLCD_E_PIN , GPIO_PIN_LOW);
 8008238:	2200      	movs	r2, #0
 800823a:	2108      	movs	r1, #8
 800823c:	2000      	movs	r0, #0
 800823e:	f000 fa8f 	bl	8008760 <GPIO_SetPinVal>

		/* Delay for 1 ms */
		SERV_Delay_ms(1);
 8008242:	2001      	movs	r0, #1
 8008244:	f000 fb44 	bl	80088d0 <SERV_Delay_ms>

		/* Check Selected CLCD Mode */
		#if CLCD_MODE == FOUR_BIT_MODE

			/* Get command most significant bits */
			Local_Bit7 = READ_BIT(Copy_Command,7);
 8008248:	79fb      	ldrb	r3, [r7, #7]
 800824a:	09db      	lsrs	r3, r3, #7
 800824c:	75bb      	strb	r3, [r7, #22]
			Local_Bit6 = READ_BIT(Copy_Command,6);
 800824e:	79fb      	ldrb	r3, [r7, #7]
 8008250:	099b      	lsrs	r3, r3, #6
 8008252:	b2db      	uxtb	r3, r3
 8008254:	f003 0301 	and.w	r3, r3, #1
 8008258:	757b      	strb	r3, [r7, #21]
			Local_Bit5 = READ_BIT(Copy_Command,5);
 800825a:	79fb      	ldrb	r3, [r7, #7]
 800825c:	095b      	lsrs	r3, r3, #5
 800825e:	b2db      	uxtb	r3, r3
 8008260:	f003 0301 	and.w	r3, r3, #1
 8008264:	753b      	strb	r3, [r7, #20]
			Local_Bit4 = READ_BIT(Copy_Command,4);
 8008266:	79fb      	ldrb	r3, [r7, #7]
 8008268:	091b      	lsrs	r3, r3, #4
 800826a:	b2db      	uxtb	r3, r3
 800826c:	f003 0301 	and.w	r3, r3, #1
 8008270:	74fb      	strb	r3, [r7, #19]

			/* Set E to HIGH tell CLCD to start reading the command */
			GPIO_SetPinVal(CLCD_CTRL_PINS_PORT , CLCD_E_PIN , GPIO_PIN_HIGH);
 8008272:	2201      	movs	r2, #1
 8008274:	2108      	movs	r1, #8
 8008276:	2000      	movs	r0, #0
 8008278:	f000 fa72 	bl	8008760 <GPIO_SetPinVal>

			/* Delay for 1 ms */
			SERV_Delay_ms(1);
 800827c:	2001      	movs	r0, #1
 800827e:	f000 fb27 	bl	80088d0 <SERV_Delay_ms>

			/* Set command most significant bits on CLCD data port */
			GPIO_SetPinVal(CLCD_DATA_PORT,CLCD_D7_PIN,Local_Bit7);
 8008282:	7dbb      	ldrb	r3, [r7, #22]
 8008284:	461a      	mov	r2, r3
 8008286:	210c      	movs	r1, #12
 8008288:	2001      	movs	r0, #1
 800828a:	f000 fa69 	bl	8008760 <GPIO_SetPinVal>
			GPIO_SetPinVal(CLCD_DATA_PORT,CLCD_D6_PIN,Local_Bit6);
 800828e:	7d7b      	ldrb	r3, [r7, #21]
 8008290:	461a      	mov	r2, r3
 8008292:	210d      	movs	r1, #13
 8008294:	2001      	movs	r0, #1
 8008296:	f000 fa63 	bl	8008760 <GPIO_SetPinVal>
			GPIO_SetPinVal(CLCD_DATA_PORT,CLCD_D5_PIN,Local_Bit5);
 800829a:	7d3b      	ldrb	r3, [r7, #20]
 800829c:	461a      	mov	r2, r3
 800829e:	210e      	movs	r1, #14
 80082a0:	2001      	movs	r0, #1
 80082a2:	f000 fa5d 	bl	8008760 <GPIO_SetPinVal>
			GPIO_SetPinVal(CLCD_DATA_PORT,CLCD_D4_PIN,Local_Bit4);
 80082a6:	7cfb      	ldrb	r3, [r7, #19]
 80082a8:	461a      	mov	r2, r3
 80082aa:	210f      	movs	r1, #15
 80082ac:	2001      	movs	r0, #1
 80082ae:	f000 fa57 	bl	8008760 <GPIO_SetPinVal>

			/* Delay for 1 ms */
			SERV_Delay_ms(1);
 80082b2:	2001      	movs	r0, #1
 80082b4:	f000 fb0c 	bl	80088d0 <SERV_Delay_ms>

			/* Set E to LOW tell CLCD to stop reading the command */
			GPIO_SetPinVal(CLCD_CTRL_PINS_PORT , CLCD_E_PIN , GPIO_PIN_LOW);
 80082b8:	2200      	movs	r2, #0
 80082ba:	2108      	movs	r1, #8
 80082bc:	2000      	movs	r0, #0
 80082be:	f000 fa4f 	bl	8008760 <GPIO_SetPinVal>

			/* Delay for 1 ms */
			SERV_Delay_ms(1);
 80082c2:	2001      	movs	r0, #1
 80082c4:	f000 fb04 	bl	80088d0 <SERV_Delay_ms>

			/* Get command least significant bits */
			Local_Bit3 = READ_BIT(Copy_Command,3);
 80082c8:	79fb      	ldrb	r3, [r7, #7]
 80082ca:	08db      	lsrs	r3, r3, #3
 80082cc:	b2db      	uxtb	r3, r3
 80082ce:	f003 0301 	and.w	r3, r3, #1
 80082d2:	74bb      	strb	r3, [r7, #18]
			Local_Bit2 = READ_BIT(Copy_Command,2);
 80082d4:	79fb      	ldrb	r3, [r7, #7]
 80082d6:	089b      	lsrs	r3, r3, #2
 80082d8:	b2db      	uxtb	r3, r3
 80082da:	f003 0301 	and.w	r3, r3, #1
 80082de:	747b      	strb	r3, [r7, #17]
			Local_Bit1 = READ_BIT(Copy_Command,1);
 80082e0:	79fb      	ldrb	r3, [r7, #7]
 80082e2:	085b      	lsrs	r3, r3, #1
 80082e4:	b2db      	uxtb	r3, r3
 80082e6:	f003 0301 	and.w	r3, r3, #1
 80082ea:	743b      	strb	r3, [r7, #16]
			Local_Bit0 = READ_BIT(Copy_Command,0);
 80082ec:	79fb      	ldrb	r3, [r7, #7]
 80082ee:	f003 0301 	and.w	r3, r3, #1
 80082f2:	73fb      	strb	r3, [r7, #15]

			/* Set E to HIGH tell CLCD to start reading the command */
			GPIO_SetPinVal(CLCD_CTRL_PINS_PORT , CLCD_E_PIN , GPIO_PIN_HIGH);
 80082f4:	2201      	movs	r2, #1
 80082f6:	2108      	movs	r1, #8
 80082f8:	2000      	movs	r0, #0
 80082fa:	f000 fa31 	bl	8008760 <GPIO_SetPinVal>

			/* Delay for 1 ms */
			SERV_Delay_ms(1);
 80082fe:	2001      	movs	r0, #1
 8008300:	f000 fae6 	bl	80088d0 <SERV_Delay_ms>

			/* Set command least significant bits on CLCD data port */
			GPIO_SetPinVal(CLCD_DATA_PORT,CLCD_D7_PIN,Local_Bit3);
 8008304:	7cbb      	ldrb	r3, [r7, #18]
 8008306:	461a      	mov	r2, r3
 8008308:	210c      	movs	r1, #12
 800830a:	2001      	movs	r0, #1
 800830c:	f000 fa28 	bl	8008760 <GPIO_SetPinVal>
			GPIO_SetPinVal(CLCD_DATA_PORT,CLCD_D6_PIN,Local_Bit2);
 8008310:	7c7b      	ldrb	r3, [r7, #17]
 8008312:	461a      	mov	r2, r3
 8008314:	210d      	movs	r1, #13
 8008316:	2001      	movs	r0, #1
 8008318:	f000 fa22 	bl	8008760 <GPIO_SetPinVal>
			GPIO_SetPinVal(CLCD_DATA_PORT,CLCD_D5_PIN,Local_Bit1);
 800831c:	7c3b      	ldrb	r3, [r7, #16]
 800831e:	461a      	mov	r2, r3
 8008320:	210e      	movs	r1, #14
 8008322:	2001      	movs	r0, #1
 8008324:	f000 fa1c 	bl	8008760 <GPIO_SetPinVal>
			GPIO_SetPinVal(CLCD_DATA_PORT,CLCD_D4_PIN,Local_Bit0);
 8008328:	7bfb      	ldrb	r3, [r7, #15]
 800832a:	461a      	mov	r2, r3
 800832c:	210f      	movs	r1, #15
 800832e:	2001      	movs	r0, #1
 8008330:	f000 fa16 	bl	8008760 <GPIO_SetPinVal>

			/* Delay for 1 ms */
			SERV_Delay_ms(1);
 8008334:	2001      	movs	r0, #1
 8008336:	f000 facb 	bl	80088d0 <SERV_Delay_ms>

			/* Clear E to tell CLCD to stop reading the command */
			GPIO_SetPinVal(CLCD_CTRL_PINS_PORT , CLCD_E_PIN , GPIO_PIN_LOW);
 800833a:	2200      	movs	r2, #0
 800833c:	2108      	movs	r1, #8
 800833e:	2000      	movs	r0, #0
 8008340:	f000 fa0e 	bl	8008760 <GPIO_SetPinVal>

			/* Delay for 2 ms */
			SERV_Delay_ms(2);
 8008344:	2002      	movs	r0, #2
 8008346:	f000 fac3 	bl	80088d0 <SERV_Delay_ms>
 800834a:	e001      	b.n	8008350 <CLCD_SendCommand+0x192>

	}
	else
	{
		/* Function is not behaving as expected */
		Local_Status = RT_NOK;
 800834c:	2301      	movs	r3, #1
 800834e:	75fb      	strb	r3, [r7, #23]
	}

	return Local_Status;
 8008350:	7dfb      	ldrb	r3, [r7, #23]
}
 8008352:	4618      	mov	r0, r3
 8008354:	3718      	adds	r7, #24
 8008356:	46bd      	mov	sp, r7
 8008358:	bd80      	pop	{r7, pc}

0800835a <CLCD_WriteCharacter>:
/* @Return		 : ERROR_STATUS_t                                          		  */
/*--------------------------------------------------------------------------------*/
/* @Description	 : Write a character on Character CLCD		                      */
/*--------------------------------------------------------------------------------*/
ERROR_STATUS_t CLCD_WriteCharacter(uint8_t Copy_Character)
{
 800835a:	b580      	push	{r7, lr}
 800835c:	b084      	sub	sp, #16
 800835e:	af00      	add	r7, sp, #0
 8008360:	4603      	mov	r3, r0
 8008362:	71fb      	strb	r3, [r7, #7]
	/* Local Variables Definitions */
	ERROR_STATUS_t Local_Status = RT_OK ;
 8008364:	2300      	movs	r3, #0
 8008366:	73fb      	strb	r3, [r7, #15]

	/* Check if passed command is valid or not */
	if(Copy_Character >= 0 && Copy_Character <= 255)
	{
		/* Set RS to HIGH to tell CLCD to receive character */
		GPIO_SetPinVal(CLCD_CTRL_PINS_PORT , CLCD_RS_PIN , GPIO_PIN_HIGH);
 8008368:	2201      	movs	r2, #1
 800836a:	2109      	movs	r1, #9
 800836c:	2000      	movs	r0, #0
 800836e:	f000 f9f7 	bl	8008760 <GPIO_SetPinVal>

		/* Delay for 1 ms */
		SERV_Delay_ms(1);
 8008372:	2001      	movs	r0, #1
 8008374:	f000 faac 	bl	80088d0 <SERV_Delay_ms>

		/* Set E to LOW tell CLCD to stop reading the character */
		GPIO_SetPinVal(CLCD_CTRL_PINS_PORT , CLCD_E_PIN , GPIO_PIN_LOW);
 8008378:	2200      	movs	r2, #0
 800837a:	2108      	movs	r1, #8
 800837c:	2000      	movs	r0, #0
 800837e:	f000 f9ef 	bl	8008760 <GPIO_SetPinVal>

		/* Delay for 1 ms */
		SERV_Delay_ms(1);
 8008382:	2001      	movs	r0, #1
 8008384:	f000 faa4 	bl	80088d0 <SERV_Delay_ms>

		/* Check Selected CLCD Mode */
		#if CLCD_MODE == FOUR_BIT_MODE

			/* Get character most significant bits */
			Local_Bit7 = READ_BIT(Copy_Character,7);
 8008388:	79fb      	ldrb	r3, [r7, #7]
 800838a:	09db      	lsrs	r3, r3, #7
 800838c:	73bb      	strb	r3, [r7, #14]
			Local_Bit6 = READ_BIT(Copy_Character,6);
 800838e:	79fb      	ldrb	r3, [r7, #7]
 8008390:	099b      	lsrs	r3, r3, #6
 8008392:	b2db      	uxtb	r3, r3
 8008394:	f003 0301 	and.w	r3, r3, #1
 8008398:	737b      	strb	r3, [r7, #13]
			Local_Bit5 = READ_BIT(Copy_Character,5);
 800839a:	79fb      	ldrb	r3, [r7, #7]
 800839c:	095b      	lsrs	r3, r3, #5
 800839e:	b2db      	uxtb	r3, r3
 80083a0:	f003 0301 	and.w	r3, r3, #1
 80083a4:	733b      	strb	r3, [r7, #12]
			Local_Bit4 = READ_BIT(Copy_Character,4);
 80083a6:	79fb      	ldrb	r3, [r7, #7]
 80083a8:	091b      	lsrs	r3, r3, #4
 80083aa:	b2db      	uxtb	r3, r3
 80083ac:	f003 0301 	and.w	r3, r3, #1
 80083b0:	72fb      	strb	r3, [r7, #11]

			/* Set E to HIGH tell CLCD to start reading the character */
			GPIO_SetPinVal(CLCD_CTRL_PINS_PORT , CLCD_E_PIN , GPIO_PIN_HIGH);
 80083b2:	2201      	movs	r2, #1
 80083b4:	2108      	movs	r1, #8
 80083b6:	2000      	movs	r0, #0
 80083b8:	f000 f9d2 	bl	8008760 <GPIO_SetPinVal>

			/* Delay for 1 ms */
			SERV_Delay_ms(1);
 80083bc:	2001      	movs	r0, #1
 80083be:	f000 fa87 	bl	80088d0 <SERV_Delay_ms>

			/* Set character most significant bits on CLCD data port */
			GPIO_SetPinVal(CLCD_DATA_PORT,CLCD_D7_PIN,Local_Bit7);
 80083c2:	7bbb      	ldrb	r3, [r7, #14]
 80083c4:	461a      	mov	r2, r3
 80083c6:	210c      	movs	r1, #12
 80083c8:	2001      	movs	r0, #1
 80083ca:	f000 f9c9 	bl	8008760 <GPIO_SetPinVal>
			GPIO_SetPinVal(CLCD_DATA_PORT,CLCD_D6_PIN,Local_Bit6);
 80083ce:	7b7b      	ldrb	r3, [r7, #13]
 80083d0:	461a      	mov	r2, r3
 80083d2:	210d      	movs	r1, #13
 80083d4:	2001      	movs	r0, #1
 80083d6:	f000 f9c3 	bl	8008760 <GPIO_SetPinVal>
			GPIO_SetPinVal(CLCD_DATA_PORT,CLCD_D5_PIN,Local_Bit5);
 80083da:	7b3b      	ldrb	r3, [r7, #12]
 80083dc:	461a      	mov	r2, r3
 80083de:	210e      	movs	r1, #14
 80083e0:	2001      	movs	r0, #1
 80083e2:	f000 f9bd 	bl	8008760 <GPIO_SetPinVal>
			GPIO_SetPinVal(CLCD_DATA_PORT,CLCD_D4_PIN,Local_Bit4);
 80083e6:	7afb      	ldrb	r3, [r7, #11]
 80083e8:	461a      	mov	r2, r3
 80083ea:	210f      	movs	r1, #15
 80083ec:	2001      	movs	r0, #1
 80083ee:	f000 f9b7 	bl	8008760 <GPIO_SetPinVal>

			/* Delay for 1 ms */
			SERV_Delay_ms(1);
 80083f2:	2001      	movs	r0, #1
 80083f4:	f000 fa6c 	bl	80088d0 <SERV_Delay_ms>

			/* Set E to LOW tell CLCD to stop reading the character */
			GPIO_SetPinVal(CLCD_CTRL_PINS_PORT , CLCD_E_PIN , GPIO_PIN_LOW);
 80083f8:	2200      	movs	r2, #0
 80083fa:	2108      	movs	r1, #8
 80083fc:	2000      	movs	r0, #0
 80083fe:	f000 f9af 	bl	8008760 <GPIO_SetPinVal>

			/* Delay for 1 ms */
			SERV_Delay_ms(1);
 8008402:	2001      	movs	r0, #1
 8008404:	f000 fa64 	bl	80088d0 <SERV_Delay_ms>

			/* Get character least significant bits */
			Local_Bit7 = READ_BIT(Copy_Character,3);
 8008408:	79fb      	ldrb	r3, [r7, #7]
 800840a:	08db      	lsrs	r3, r3, #3
 800840c:	b2db      	uxtb	r3, r3
 800840e:	f003 0301 	and.w	r3, r3, #1
 8008412:	73bb      	strb	r3, [r7, #14]
			Local_Bit6 = READ_BIT(Copy_Character,2);
 8008414:	79fb      	ldrb	r3, [r7, #7]
 8008416:	089b      	lsrs	r3, r3, #2
 8008418:	b2db      	uxtb	r3, r3
 800841a:	f003 0301 	and.w	r3, r3, #1
 800841e:	737b      	strb	r3, [r7, #13]
			Local_Bit5 = READ_BIT(Copy_Character,1);
 8008420:	79fb      	ldrb	r3, [r7, #7]
 8008422:	085b      	lsrs	r3, r3, #1
 8008424:	b2db      	uxtb	r3, r3
 8008426:	f003 0301 	and.w	r3, r3, #1
 800842a:	733b      	strb	r3, [r7, #12]
			Local_Bit4 = READ_BIT(Copy_Character,0);
 800842c:	79fb      	ldrb	r3, [r7, #7]
 800842e:	f003 0301 	and.w	r3, r3, #1
 8008432:	72fb      	strb	r3, [r7, #11]

			/* Set E to HIGH tell CLCD to start reading the character */
			GPIO_SetPinVal(CLCD_CTRL_PINS_PORT , CLCD_E_PIN , GPIO_PIN_HIGH);
 8008434:	2201      	movs	r2, #1
 8008436:	2108      	movs	r1, #8
 8008438:	2000      	movs	r0, #0
 800843a:	f000 f991 	bl	8008760 <GPIO_SetPinVal>

			/* Delay for 1 ms */
			SERV_Delay_ms(1);
 800843e:	2001      	movs	r0, #1
 8008440:	f000 fa46 	bl	80088d0 <SERV_Delay_ms>

			/* Set character least significant bits on CLCD data port */
			GPIO_SetPinVal(CLCD_DATA_PORT,CLCD_D7_PIN,Local_Bit7);
 8008444:	7bbb      	ldrb	r3, [r7, #14]
 8008446:	461a      	mov	r2, r3
 8008448:	210c      	movs	r1, #12
 800844a:	2001      	movs	r0, #1
 800844c:	f000 f988 	bl	8008760 <GPIO_SetPinVal>
			GPIO_SetPinVal(CLCD_DATA_PORT,CLCD_D6_PIN,Local_Bit6);
 8008450:	7b7b      	ldrb	r3, [r7, #13]
 8008452:	461a      	mov	r2, r3
 8008454:	210d      	movs	r1, #13
 8008456:	2001      	movs	r0, #1
 8008458:	f000 f982 	bl	8008760 <GPIO_SetPinVal>
			GPIO_SetPinVal(CLCD_DATA_PORT,CLCD_D5_PIN,Local_Bit5);
 800845c:	7b3b      	ldrb	r3, [r7, #12]
 800845e:	461a      	mov	r2, r3
 8008460:	210e      	movs	r1, #14
 8008462:	2001      	movs	r0, #1
 8008464:	f000 f97c 	bl	8008760 <GPIO_SetPinVal>
			GPIO_SetPinVal(CLCD_DATA_PORT,CLCD_D4_PIN,Local_Bit4);
 8008468:	7afb      	ldrb	r3, [r7, #11]
 800846a:	461a      	mov	r2, r3
 800846c:	210f      	movs	r1, #15
 800846e:	2001      	movs	r0, #1
 8008470:	f000 f976 	bl	8008760 <GPIO_SetPinVal>

			/* Delay for 1 ms */
			SERV_Delay_ms(1);
 8008474:	2001      	movs	r0, #1
 8008476:	f000 fa2b 	bl	80088d0 <SERV_Delay_ms>

			/* Clear E to tell CLCD to stop reading the character */
			GPIO_SetPinVal(CLCD_CTRL_PINS_PORT , CLCD_E_PIN , GPIO_PIN_LOW);
 800847a:	2200      	movs	r2, #0
 800847c:	2108      	movs	r1, #8
 800847e:	2000      	movs	r0, #0
 8008480:	f000 f96e 	bl	8008760 <GPIO_SetPinVal>

			/* Delay for 2 ms */
			SERV_Delay_ms(2);
 8008484:	2002      	movs	r0, #2
 8008486:	f000 fa23 	bl	80088d0 <SERV_Delay_ms>
	{
		/* Function is not behaving as expected */
		Local_Status = RT_NOK;
	}

	return Local_Status;
 800848a:	7bfb      	ldrb	r3, [r7, #15]
}
 800848c:	4618      	mov	r0, r3
 800848e:	3710      	adds	r7, #16
 8008490:	46bd      	mov	sp, r7
 8008492:	bd80      	pop	{r7, pc}

08008494 <CLCD_SetFourBitMode>:
/* @Return		 : void                                          				  */
/*--------------------------------------------------------------------------------*/
/* @Description	 : Set up Character LCD on 4-bit mode							  */
/*--------------------------------------------------------------------------------*/
void CLCD_SetFourBitMode(void)
{
 8008494:	b580      	push	{r7, lr}
 8008496:	af00      	add	r7, sp, #0
	 CLCD_SendCommand(CLCD_FUNCTION_SET_FOUR_BIT_MODE_CMD);
 8008498:	2028      	movs	r0, #40	; 0x28
 800849a:	f7ff fe90 	bl	80081be <CLCD_SendCommand>
}
 800849e:	bf00      	nop
 80084a0:	bd80      	pop	{r7, pc}

080084a2 <CLCD_DisplayOnCursorOff>:
/* @Return		 : void                                          				  */
/*--------------------------------------------------------------------------------*/
/* @Description	 : Turn on display and turn off cursor							  */
/*--------------------------------------------------------------------------------*/
void CLCD_DisplayOnCursorOff(void)
{
 80084a2:	b580      	push	{r7, lr}
 80084a4:	af00      	add	r7, sp, #0
	 CLCD_SendCommand(CLCD_DISPLAY_ON_CURSOR_OFF_CMD);
 80084a6:	200c      	movs	r0, #12
 80084a8:	f7ff fe89 	bl	80081be <CLCD_SendCommand>
}
 80084ac:	bf00      	nop
 80084ae:	bd80      	pop	{r7, pc}

080084b0 <CLCD_BeginAtSecondLine>:
/* @Return		 : void                                          				  */
/*--------------------------------------------------------------------------------*/
/* @Description	 : Force cursor to be at the beginning of the second line		  */
/*--------------------------------------------------------------------------------*/
void CLCD_BeginAtSecondLine(void)
{
 80084b0:	b580      	push	{r7, lr}
 80084b2:	af00      	add	r7, sp, #0
	CLCD_SendCommand(CLCD_BEGIN_AT_SECOND_LINE_CMD);
 80084b4:	20c0      	movs	r0, #192	; 0xc0
 80084b6:	f7ff fe82 	bl	80081be <CLCD_SendCommand>
}
 80084ba:	bf00      	nop
 80084bc:	bd80      	pop	{r7, pc}

080084be <CLCD_ClearDisplay>:
/* @Return		 : void                                          				  */
/*--------------------------------------------------------------------------------*/
/* @Description	 : Clear the entire display of character LCD		 			  */
/*--------------------------------------------------------------------------------*/
void CLCD_ClearDisplay(void)
{
 80084be:	b580      	push	{r7, lr}
 80084c0:	af00      	add	r7, sp, #0
	CLCD_SendCommand(CLCD_DISPLAY_CLEAR_CMD);
 80084c2:	2001      	movs	r0, #1
 80084c4:	f7ff fe7b 	bl	80081be <CLCD_SendCommand>
}
 80084c8:	bf00      	nop
 80084ca:	bd80      	pop	{r7, pc}

080084cc <CLCD_SetEntryMode>:
/* @Return		 : void                                          				  */
/*--------------------------------------------------------------------------------*/
/* @Description	 : Set up character LCD to operate on the entry mode		 	  */
/*--------------------------------------------------------------------------------*/
void CLCD_SetEntryMode(void)
{
 80084cc:	b580      	push	{r7, lr}
 80084ce:	af00      	add	r7, sp, #0
	CLCD_SendCommand(CLCD_ENTRY_MODE_CMD);
 80084d0:	2006      	movs	r0, #6
 80084d2:	f7ff fe74 	bl	80081be <CLCD_SendCommand>
}
 80084d6:	bf00      	nop
 80084d8:	bd80      	pop	{r7, pc}

080084da <CLCD_WriteString>:
/* @Return		 : ERROR_STATUS_t                                          		  */
/*--------------------------------------------------------------------------------*/
/* @Description	 : Write a string on the Character LCD display      		 	  */
/*--------------------------------------------------------------------------------*/
ERROR_STATUS_t CLCD_WriteString(uint8_t* Copy_pString)
{
 80084da:	b580      	push	{r7, lr}
 80084dc:	b084      	sub	sp, #16
 80084de:	af00      	add	r7, sp, #0
 80084e0:	6078      	str	r0, [r7, #4]
	/* Local Variables Definitions */
	ERROR_STATUS_t Local_Status = RT_OK ;
 80084e2:	2300      	movs	r3, #0
 80084e4:	73fb      	strb	r3, [r7, #15]
	uint32_t Local_CharacterCounter = 0 ;
 80084e6:	2300      	movs	r3, #0
 80084e8:	60bb      	str	r3, [r7, #8]

	/* Check if passed pointer is NULL pointer or not */
	if(Copy_pString != NULL)
 80084ea:	687b      	ldr	r3, [r7, #4]
 80084ec:	2b00      	cmp	r3, #0
 80084ee:	d016      	beq.n	800851e <CLCD_WriteString+0x44>
	{
		/* Write the passed string on the CLCD display */
		while(Copy_pString[Local_CharacterCounter] != '\0')
 80084f0:	e00e      	b.n	8008510 <CLCD_WriteString+0x36>
		{
			/* Write a character */
			CLCD_WriteCharacter(Copy_pString[Local_CharacterCounter]);
 80084f2:	687a      	ldr	r2, [r7, #4]
 80084f4:	68bb      	ldr	r3, [r7, #8]
 80084f6:	4413      	add	r3, r2
 80084f8:	781b      	ldrb	r3, [r3, #0]
 80084fa:	4618      	mov	r0, r3
 80084fc:	f7ff ff2d 	bl	800835a <CLCD_WriteCharacter>

			/* Increment the character counter */
			Local_CharacterCounter++;
 8008500:	68bb      	ldr	r3, [r7, #8]
 8008502:	3301      	adds	r3, #1
 8008504:	60bb      	str	r3, [r7, #8]

			/* Check if the character counter reached 16 or not */
			if(Local_CharacterCounter == 20)
 8008506:	68bb      	ldr	r3, [r7, #8]
 8008508:	2b14      	cmp	r3, #20
 800850a:	d101      	bne.n	8008510 <CLCD_WriteString+0x36>
			{
				/* Force CLCD cursor to begin at second line */
				CLCD_BeginAtSecondLine();
 800850c:	f7ff ffd0 	bl	80084b0 <CLCD_BeginAtSecondLine>
		while(Copy_pString[Local_CharacterCounter] != '\0')
 8008510:	687a      	ldr	r2, [r7, #4]
 8008512:	68bb      	ldr	r3, [r7, #8]
 8008514:	4413      	add	r3, r2
 8008516:	781b      	ldrb	r3, [r3, #0]
 8008518:	2b00      	cmp	r3, #0
 800851a:	d1ea      	bne.n	80084f2 <CLCD_WriteString+0x18>
 800851c:	e001      	b.n	8008522 <CLCD_WriteString+0x48>
		}
	}
	else
	{
		/* Passed pointer is NULL pointer */
		Local_Status = NULL_POINTER;
 800851e:	2302      	movs	r3, #2
 8008520:	73fb      	strb	r3, [r7, #15]
	}

	return Local_Status;
 8008522:	7bfb      	ldrb	r3, [r7, #15]
}
 8008524:	4618      	mov	r0, r3
 8008526:	3710      	adds	r7, #16
 8008528:	46bd      	mov	sp, r7
 800852a:	bd80      	pop	{r7, pc}

0800852c <CLCD_MoveCursor>:
/*--------------------------------------------------------------------------------*/
/* @Description	 : Put the cursor at a specific location (segment) on the         */
/*                 character LCD display					                      */
/*--------------------------------------------------------------------------------*/
ERROR_STATUS_t CLCD_MoveCursor(uint8_t Copy_RowNumber , uint8_t Copy_ColumnNumber)
{
 800852c:	b580      	push	{r7, lr}
 800852e:	b084      	sub	sp, #16
 8008530:	af00      	add	r7, sp, #0
 8008532:	4603      	mov	r3, r0
 8008534:	460a      	mov	r2, r1
 8008536:	71fb      	strb	r3, [r7, #7]
 8008538:	4613      	mov	r3, r2
 800853a:	71bb      	strb	r3, [r7, #6]
	/* Local Variables Definitions */
	ERROR_STATUS_t Local_Status = RT_OK ;
 800853c:	2300      	movs	r3, #0
 800853e:	73fb      	strb	r3, [r7, #15]

	/* Check if passed column number is within valid range or not */
	if((Copy_ColumnNumber >= 0) && (Copy_ColumnNumber <= 19))
 8008540:	79bb      	ldrb	r3, [r7, #6]
 8008542:	2b13      	cmp	r3, #19
 8008544:	d816      	bhi.n	8008574 <CLCD_MoveCursor+0x48>
	{
		switch(Copy_RowNumber)
 8008546:	79fb      	ldrb	r3, [r7, #7]
 8008548:	2b00      	cmp	r3, #0
 800854a:	d002      	beq.n	8008552 <CLCD_MoveCursor+0x26>
 800854c:	2b01      	cmp	r3, #1
 800854e:	d007      	beq.n	8008560 <CLCD_MoveCursor+0x34>
 8008550:	e00d      	b.n	800856e <CLCD_MoveCursor+0x42>
		{
			case 0:

				/* Move the cursor to desired cell number on row 0 */
				CLCD_SendCommand(Copy_ColumnNumber+0x80);
 8008552:	79bb      	ldrb	r3, [r7, #6]
 8008554:	3b80      	subs	r3, #128	; 0x80
 8008556:	b2db      	uxtb	r3, r3
 8008558:	4618      	mov	r0, r3
 800855a:	f7ff fe30 	bl	80081be <CLCD_SendCommand>
				break;
 800855e:	e00b      	b.n	8008578 <CLCD_MoveCursor+0x4c>

			case 1:

				/* Move the cursor to desired cell number on row 1 */
				CLCD_SendCommand(Copy_ColumnNumber+0xC0);
 8008560:	79bb      	ldrb	r3, [r7, #6]
 8008562:	3b40      	subs	r3, #64	; 0x40
 8008564:	b2db      	uxtb	r3, r3
 8008566:	4618      	mov	r0, r3
 8008568:	f7ff fe29 	bl	80081be <CLCD_SendCommand>
				break;
 800856c:	e004      	b.n	8008578 <CLCD_MoveCursor+0x4c>

			default:

				/* Function is not behaving as expected */
				Local_Status = RT_NOK;
 800856e:	2301      	movs	r3, #1
 8008570:	73fb      	strb	r3, [r7, #15]
 8008572:	e001      	b.n	8008578 <CLCD_MoveCursor+0x4c>
		}
	}
	else
	{
		/* Function is not behaving as expected */
		Local_Status = RT_NOK;
 8008574:	2301      	movs	r3, #1
 8008576:	73fb      	strb	r3, [r7, #15]
	}

	return Local_Status ;
 8008578:	7bfb      	ldrb	r3, [r7, #15]
}
 800857a:	4618      	mov	r0, r3
 800857c:	3710      	adds	r7, #16
 800857e:	46bd      	mov	sp, r7
 8008580:	bd80      	pop	{r7, pc}
	...

08008584 <GPIO_SetPinMode>:
/* @Return		 : ERROR_STATUS_t												  */
/*--------------------------------------------------------------------------------*/
/* @Description	 : Sets the mode of operation of GPIO pin                         */
/*--------------------------------------------------------------------------------*/
ERROR_STATUS_t GPIO_SetPinMode(uint8_t Copy_Port , uint8_t Copy_Pin , uint8_t Copy_Mode)
{
 8008584:	b480      	push	{r7}
 8008586:	b085      	sub	sp, #20
 8008588:	af00      	add	r7, sp, #0
 800858a:	4603      	mov	r3, r0
 800858c:	71fb      	strb	r3, [r7, #7]
 800858e:	460b      	mov	r3, r1
 8008590:	71bb      	strb	r3, [r7, #6]
 8008592:	4613      	mov	r3, r2
 8008594:	717b      	strb	r3, [r7, #5]
	/* Local Variables Definitions */
	ERROR_STATUS_t Local_Status = RT_OK;
 8008596:	2300      	movs	r3, #0
 8008598:	73fb      	strb	r3, [r7, #15]

	/* Check if passed port, pin and mode are valid or not */
	if((Copy_Port >= GPIO_PORT_A && Copy_Port <= GPIO_PORT_C) && (Copy_Pin >= GPIO_PIN_0 && Copy_Pin <= GPIO_PIN_15) &&
 800859a:	79fb      	ldrb	r3, [r7, #7]
 800859c:	2b02      	cmp	r3, #2
 800859e:	f200 80d0 	bhi.w	8008742 <GPIO_SetPinMode+0x1be>
 80085a2:	79bb      	ldrb	r3, [r7, #6]
 80085a4:	2b0f      	cmp	r3, #15
 80085a6:	f200 80cc 	bhi.w	8008742 <GPIO_SetPinMode+0x1be>
 80085aa:	797b      	ldrb	r3, [r7, #5]
 80085ac:	2b00      	cmp	r3, #0
 80085ae:	d02a      	beq.n	8008606 <GPIO_SetPinMode+0x82>
	   (Copy_Mode == GPIO_PIN_INPUT_ANALOG || Copy_Mode == GPIO_PIN_INPUT_FLOATING || Copy_Mode == GPIO_PIN_INPUT_PULLUP_PULLDOWN ||
 80085b0:	797b      	ldrb	r3, [r7, #5]
 80085b2:	2b04      	cmp	r3, #4
 80085b4:	d027      	beq.n	8008606 <GPIO_SetPinMode+0x82>
 80085b6:	797b      	ldrb	r3, [r7, #5]
 80085b8:	2b08      	cmp	r3, #8
 80085ba:	d024      	beq.n	8008606 <GPIO_SetPinMode+0x82>
 80085bc:	797b      	ldrb	r3, [r7, #5]
 80085be:	2b01      	cmp	r3, #1
 80085c0:	d021      	beq.n	8008606 <GPIO_SetPinMode+0x82>
		Copy_Mode == GPIO_PIN_OUTPUT_SPEED_10MHZ_PUSHPULL    || Copy_Mode == GPIO_PIN_OUTPUT_SPEED_10MHZ_OPENDRAIN    ||
 80085c2:	797b      	ldrb	r3, [r7, #5]
 80085c4:	2b05      	cmp	r3, #5
 80085c6:	d01e      	beq.n	8008606 <GPIO_SetPinMode+0x82>
 80085c8:	797b      	ldrb	r3, [r7, #5]
 80085ca:	2b09      	cmp	r3, #9
 80085cc:	d01b      	beq.n	8008606 <GPIO_SetPinMode+0x82>
		Copy_Mode == GPIO_PIN_OUTPUT_SPEED_10MHZ_AF_PUSHPULL || Copy_Mode == GPIO_PIN_OUTPUT_SPEED_10MHZ_AF_OPENDRAIN ||
 80085ce:	797b      	ldrb	r3, [r7, #5]
 80085d0:	2b0d      	cmp	r3, #13
 80085d2:	d018      	beq.n	8008606 <GPIO_SetPinMode+0x82>
 80085d4:	797b      	ldrb	r3, [r7, #5]
 80085d6:	2b02      	cmp	r3, #2
 80085d8:	d015      	beq.n	8008606 <GPIO_SetPinMode+0x82>
		Copy_Mode == GPIO_PIN_OUTPUT_SPEED_2MHZ_PUSHPULL     || Copy_Mode == GPIO_PIN_OUTPUT_SPEED_2MHZ_OPENDRAIN     ||
 80085da:	797b      	ldrb	r3, [r7, #5]
 80085dc:	2b06      	cmp	r3, #6
 80085de:	d012      	beq.n	8008606 <GPIO_SetPinMode+0x82>
 80085e0:	797b      	ldrb	r3, [r7, #5]
 80085e2:	2b0a      	cmp	r3, #10
 80085e4:	d00f      	beq.n	8008606 <GPIO_SetPinMode+0x82>
		Copy_Mode == GPIO_PIN_OUTPUT_SPEED_2MHZ_AF_PUSHPULL  || Copy_Mode == GPIO_PIN_OUTPUT_SPEED_2MHZ_AF_OPENDRAIN  ||
 80085e6:	797b      	ldrb	r3, [r7, #5]
 80085e8:	2b0e      	cmp	r3, #14
 80085ea:	d00c      	beq.n	8008606 <GPIO_SetPinMode+0x82>
 80085ec:	797b      	ldrb	r3, [r7, #5]
 80085ee:	2b03      	cmp	r3, #3
 80085f0:	d009      	beq.n	8008606 <GPIO_SetPinMode+0x82>
		Copy_Mode == GPIO_PIN_OUTPUT_SPEED_50MHZ_PUSHPULL    || Copy_Mode == GPIO_PIN_OUTPUT_SPEED_50MHZ_OPENDRAIN    ||
 80085f2:	797b      	ldrb	r3, [r7, #5]
 80085f4:	2b07      	cmp	r3, #7
 80085f6:	d006      	beq.n	8008606 <GPIO_SetPinMode+0x82>
 80085f8:	797b      	ldrb	r3, [r7, #5]
 80085fa:	2b0b      	cmp	r3, #11
 80085fc:	d003      	beq.n	8008606 <GPIO_SetPinMode+0x82>
		Copy_Mode == GPIO_PIN_OUTPUT_SPEED_50MHZ_AF_PUSHPULL || Copy_Mode == GPIO_PIN_OUTPUT_SPEED_50MHZ_AF_OPENDRAIN))
 80085fe:	797b      	ldrb	r3, [r7, #5]
 8008600:	2b0f      	cmp	r3, #15
 8008602:	f040 809e 	bne.w	8008742 <GPIO_SetPinMode+0x1be>
	{
		/* Check port number */
		switch(Copy_Port)
 8008606:	79fb      	ldrb	r3, [r7, #7]
 8008608:	2b01      	cmp	r3, #1
 800860a:	d03c      	beq.n	8008686 <GPIO_SetPinMode+0x102>
 800860c:	2b02      	cmp	r3, #2
 800860e:	d072      	beq.n	80086f6 <GPIO_SetPinMode+0x172>
 8008610:	2b00      	cmp	r3, #0
 8008612:	d000      	beq.n	8008616 <GPIO_SetPinMode+0x92>
					/* Set the four bits of mode concerned with the pin in CRH register */
					GPIOC->CRH |= (Copy_Mode << (4*(Copy_Pin-8)));
				}
				break;
		}
	}
 8008614:	e097      	b.n	8008746 <GPIO_SetPinMode+0x1c2>
				if(Copy_Pin < 8)
 8008616:	79bb      	ldrb	r3, [r7, #6]
 8008618:	2b07      	cmp	r3, #7
 800861a:	d817      	bhi.n	800864c <GPIO_SetPinMode+0xc8>
					GPIOA->CRL &= ~(GPIO_PIN_MODE_MASK << (4*Copy_Pin));
 800861c:	4b4d      	ldr	r3, [pc, #308]	; (8008754 <GPIO_SetPinMode+0x1d0>)
 800861e:	681b      	ldr	r3, [r3, #0]
 8008620:	79ba      	ldrb	r2, [r7, #6]
 8008622:	0092      	lsls	r2, r2, #2
 8008624:	210f      	movs	r1, #15
 8008626:	fa01 f202 	lsl.w	r2, r1, r2
 800862a:	43d2      	mvns	r2, r2
 800862c:	4611      	mov	r1, r2
 800862e:	4a49      	ldr	r2, [pc, #292]	; (8008754 <GPIO_SetPinMode+0x1d0>)
 8008630:	400b      	ands	r3, r1
 8008632:	6013      	str	r3, [r2, #0]
					GPIOA->CRL |= (Copy_Mode << (4*Copy_Pin));
 8008634:	4b47      	ldr	r3, [pc, #284]	; (8008754 <GPIO_SetPinMode+0x1d0>)
 8008636:	681b      	ldr	r3, [r3, #0]
 8008638:	7979      	ldrb	r1, [r7, #5]
 800863a:	79ba      	ldrb	r2, [r7, #6]
 800863c:	0092      	lsls	r2, r2, #2
 800863e:	fa01 f202 	lsl.w	r2, r1, r2
 8008642:	4611      	mov	r1, r2
 8008644:	4a43      	ldr	r2, [pc, #268]	; (8008754 <GPIO_SetPinMode+0x1d0>)
 8008646:	430b      	orrs	r3, r1
 8008648:	6013      	str	r3, [r2, #0]
				break;
 800864a:	e074      	b.n	8008736 <GPIO_SetPinMode+0x1b2>
				else if(Copy_Pin < 16)
 800864c:	79bb      	ldrb	r3, [r7, #6]
 800864e:	2b0f      	cmp	r3, #15
 8008650:	d871      	bhi.n	8008736 <GPIO_SetPinMode+0x1b2>
					GPIOA->CRH &= ~(GPIO_PIN_MODE_MASK << (4*(Copy_Pin-8)));
 8008652:	4b40      	ldr	r3, [pc, #256]	; (8008754 <GPIO_SetPinMode+0x1d0>)
 8008654:	685b      	ldr	r3, [r3, #4]
 8008656:	79ba      	ldrb	r2, [r7, #6]
 8008658:	3a08      	subs	r2, #8
 800865a:	0092      	lsls	r2, r2, #2
 800865c:	210f      	movs	r1, #15
 800865e:	fa01 f202 	lsl.w	r2, r1, r2
 8008662:	43d2      	mvns	r2, r2
 8008664:	4611      	mov	r1, r2
 8008666:	4a3b      	ldr	r2, [pc, #236]	; (8008754 <GPIO_SetPinMode+0x1d0>)
 8008668:	400b      	ands	r3, r1
 800866a:	6053      	str	r3, [r2, #4]
					GPIOA->CRH |= (Copy_Mode << (4*(Copy_Pin-8)));
 800866c:	4b39      	ldr	r3, [pc, #228]	; (8008754 <GPIO_SetPinMode+0x1d0>)
 800866e:	685b      	ldr	r3, [r3, #4]
 8008670:	7979      	ldrb	r1, [r7, #5]
 8008672:	79ba      	ldrb	r2, [r7, #6]
 8008674:	3a08      	subs	r2, #8
 8008676:	0092      	lsls	r2, r2, #2
 8008678:	fa01 f202 	lsl.w	r2, r1, r2
 800867c:	4611      	mov	r1, r2
 800867e:	4a35      	ldr	r2, [pc, #212]	; (8008754 <GPIO_SetPinMode+0x1d0>)
 8008680:	430b      	orrs	r3, r1
 8008682:	6053      	str	r3, [r2, #4]
				break;
 8008684:	e057      	b.n	8008736 <GPIO_SetPinMode+0x1b2>
				if(Copy_Pin < 8)
 8008686:	79bb      	ldrb	r3, [r7, #6]
 8008688:	2b07      	cmp	r3, #7
 800868a:	d817      	bhi.n	80086bc <GPIO_SetPinMode+0x138>
					GPIOB->CRL &= ~(GPIO_PIN_MODE_MASK << (4*Copy_Pin));
 800868c:	4b32      	ldr	r3, [pc, #200]	; (8008758 <GPIO_SetPinMode+0x1d4>)
 800868e:	681b      	ldr	r3, [r3, #0]
 8008690:	79ba      	ldrb	r2, [r7, #6]
 8008692:	0092      	lsls	r2, r2, #2
 8008694:	210f      	movs	r1, #15
 8008696:	fa01 f202 	lsl.w	r2, r1, r2
 800869a:	43d2      	mvns	r2, r2
 800869c:	4611      	mov	r1, r2
 800869e:	4a2e      	ldr	r2, [pc, #184]	; (8008758 <GPIO_SetPinMode+0x1d4>)
 80086a0:	400b      	ands	r3, r1
 80086a2:	6013      	str	r3, [r2, #0]
					GPIOB->CRL |= (Copy_Mode << (4*Copy_Pin));
 80086a4:	4b2c      	ldr	r3, [pc, #176]	; (8008758 <GPIO_SetPinMode+0x1d4>)
 80086a6:	681b      	ldr	r3, [r3, #0]
 80086a8:	7979      	ldrb	r1, [r7, #5]
 80086aa:	79ba      	ldrb	r2, [r7, #6]
 80086ac:	0092      	lsls	r2, r2, #2
 80086ae:	fa01 f202 	lsl.w	r2, r1, r2
 80086b2:	4611      	mov	r1, r2
 80086b4:	4a28      	ldr	r2, [pc, #160]	; (8008758 <GPIO_SetPinMode+0x1d4>)
 80086b6:	430b      	orrs	r3, r1
 80086b8:	6013      	str	r3, [r2, #0]
				break;
 80086ba:	e03e      	b.n	800873a <GPIO_SetPinMode+0x1b6>
				else if(Copy_Pin < 16)
 80086bc:	79bb      	ldrb	r3, [r7, #6]
 80086be:	2b0f      	cmp	r3, #15
 80086c0:	d83b      	bhi.n	800873a <GPIO_SetPinMode+0x1b6>
					GPIOB->CRH &= ~(GPIO_PIN_MODE_MASK << (4*(Copy_Pin-8)));
 80086c2:	4b25      	ldr	r3, [pc, #148]	; (8008758 <GPIO_SetPinMode+0x1d4>)
 80086c4:	685b      	ldr	r3, [r3, #4]
 80086c6:	79ba      	ldrb	r2, [r7, #6]
 80086c8:	3a08      	subs	r2, #8
 80086ca:	0092      	lsls	r2, r2, #2
 80086cc:	210f      	movs	r1, #15
 80086ce:	fa01 f202 	lsl.w	r2, r1, r2
 80086d2:	43d2      	mvns	r2, r2
 80086d4:	4611      	mov	r1, r2
 80086d6:	4a20      	ldr	r2, [pc, #128]	; (8008758 <GPIO_SetPinMode+0x1d4>)
 80086d8:	400b      	ands	r3, r1
 80086da:	6053      	str	r3, [r2, #4]
					GPIOB->CRH |= (Copy_Mode << (4*(Copy_Pin-8)));
 80086dc:	4b1e      	ldr	r3, [pc, #120]	; (8008758 <GPIO_SetPinMode+0x1d4>)
 80086de:	685b      	ldr	r3, [r3, #4]
 80086e0:	7979      	ldrb	r1, [r7, #5]
 80086e2:	79ba      	ldrb	r2, [r7, #6]
 80086e4:	3a08      	subs	r2, #8
 80086e6:	0092      	lsls	r2, r2, #2
 80086e8:	fa01 f202 	lsl.w	r2, r1, r2
 80086ec:	4611      	mov	r1, r2
 80086ee:	4a1a      	ldr	r2, [pc, #104]	; (8008758 <GPIO_SetPinMode+0x1d4>)
 80086f0:	430b      	orrs	r3, r1
 80086f2:	6053      	str	r3, [r2, #4]
				break;
 80086f4:	e021      	b.n	800873a <GPIO_SetPinMode+0x1b6>
				if(Copy_Pin >= 13 && Copy_Pin <= 15)
 80086f6:	79bb      	ldrb	r3, [r7, #6]
 80086f8:	2b0c      	cmp	r3, #12
 80086fa:	d920      	bls.n	800873e <GPIO_SetPinMode+0x1ba>
 80086fc:	79bb      	ldrb	r3, [r7, #6]
 80086fe:	2b0f      	cmp	r3, #15
 8008700:	d81d      	bhi.n	800873e <GPIO_SetPinMode+0x1ba>
					GPIOC->CRH &= ~(GPIO_PIN_MODE_MASK << (4*(Copy_Pin-8)));
 8008702:	4b16      	ldr	r3, [pc, #88]	; (800875c <GPIO_SetPinMode+0x1d8>)
 8008704:	685b      	ldr	r3, [r3, #4]
 8008706:	79ba      	ldrb	r2, [r7, #6]
 8008708:	3a08      	subs	r2, #8
 800870a:	0092      	lsls	r2, r2, #2
 800870c:	210f      	movs	r1, #15
 800870e:	fa01 f202 	lsl.w	r2, r1, r2
 8008712:	43d2      	mvns	r2, r2
 8008714:	4611      	mov	r1, r2
 8008716:	4a11      	ldr	r2, [pc, #68]	; (800875c <GPIO_SetPinMode+0x1d8>)
 8008718:	400b      	ands	r3, r1
 800871a:	6053      	str	r3, [r2, #4]
					GPIOC->CRH |= (Copy_Mode << (4*(Copy_Pin-8)));
 800871c:	4b0f      	ldr	r3, [pc, #60]	; (800875c <GPIO_SetPinMode+0x1d8>)
 800871e:	685b      	ldr	r3, [r3, #4]
 8008720:	7979      	ldrb	r1, [r7, #5]
 8008722:	79ba      	ldrb	r2, [r7, #6]
 8008724:	3a08      	subs	r2, #8
 8008726:	0092      	lsls	r2, r2, #2
 8008728:	fa01 f202 	lsl.w	r2, r1, r2
 800872c:	4611      	mov	r1, r2
 800872e:	4a0b      	ldr	r2, [pc, #44]	; (800875c <GPIO_SetPinMode+0x1d8>)
 8008730:	430b      	orrs	r3, r1
 8008732:	6053      	str	r3, [r2, #4]
				break;
 8008734:	e003      	b.n	800873e <GPIO_SetPinMode+0x1ba>
				break;
 8008736:	bf00      	nop
 8008738:	e005      	b.n	8008746 <GPIO_SetPinMode+0x1c2>
				break;
 800873a:	bf00      	nop
 800873c:	e003      	b.n	8008746 <GPIO_SetPinMode+0x1c2>
				break;
 800873e:	bf00      	nop
	}
 8008740:	e001      	b.n	8008746 <GPIO_SetPinMode+0x1c2>
	else
	{
		/* Function is not behaving as expected */
		Local_Status = RT_NOK;
 8008742:	2301      	movs	r3, #1
 8008744:	73fb      	strb	r3, [r7, #15]
	}

	return Local_Status;
 8008746:	7bfb      	ldrb	r3, [r7, #15]
}
 8008748:	4618      	mov	r0, r3
 800874a:	3714      	adds	r7, #20
 800874c:	46bd      	mov	sp, r7
 800874e:	bc80      	pop	{r7}
 8008750:	4770      	bx	lr
 8008752:	bf00      	nop
 8008754:	40010800 	.word	0x40010800
 8008758:	40010c00 	.word	0x40010c00
 800875c:	40011000 	.word	0x40011000

08008760 <GPIO_SetPinVal>:
/* @Return		 : ERROR_STATUS_t												  */
/*--------------------------------------------------------------------------------*/
/* @Description	 : Sets a value (Logical High or Logical Low) on GPIO pin         */
/*--------------------------------------------------------------------------------*/
ERROR_STATUS_t GPIO_SetPinVal(uint8_t Copy_Port , uint8_t Copy_Pin , uint8_t Copy_Value)
{
 8008760:	b480      	push	{r7}
 8008762:	b085      	sub	sp, #20
 8008764:	af00      	add	r7, sp, #0
 8008766:	4603      	mov	r3, r0
 8008768:	71fb      	strb	r3, [r7, #7]
 800876a:	460b      	mov	r3, r1
 800876c:	71bb      	strb	r3, [r7, #6]
 800876e:	4613      	mov	r3, r2
 8008770:	717b      	strb	r3, [r7, #5]
	/* Local Variables Definitions */
	ERROR_STATUS_t Local_Status = RT_OK;
 8008772:	2300      	movs	r3, #0
 8008774:	73fb      	strb	r3, [r7, #15]

	/* Check if passed port, pin and value are valid or not */
	if((Copy_Port >= GPIO_PORT_A && Copy_Port <= GPIO_PORT_C) && (Copy_Pin >= GPIO_PIN_0 && Copy_Pin <= GPIO_PIN_15) &&
 8008776:	79fb      	ldrb	r3, [r7, #7]
 8008778:	2b02      	cmp	r3, #2
 800877a:	d87c      	bhi.n	8008876 <GPIO_SetPinVal+0x116>
 800877c:	79bb      	ldrb	r3, [r7, #6]
 800877e:	2b0f      	cmp	r3, #15
 8008780:	d879      	bhi.n	8008876 <GPIO_SetPinVal+0x116>
 8008782:	797b      	ldrb	r3, [r7, #5]
 8008784:	2b01      	cmp	r3, #1
 8008786:	d00e      	beq.n	80087a6 <GPIO_SetPinVal+0x46>
	   (Copy_Value == GPIO_PIN_HIGH   ||  Copy_Value == GPIO_PIN_LOW    || Copy_Value == GPIO_PIN_OD_HIGH ||
 8008788:	797b      	ldrb	r3, [r7, #5]
 800878a:	2b00      	cmp	r3, #0
 800878c:	d00b      	beq.n	80087a6 <GPIO_SetPinVal+0x46>
 800878e:	797b      	ldrb	r3, [r7, #5]
 8008790:	2b01      	cmp	r3, #1
 8008792:	d008      	beq.n	80087a6 <GPIO_SetPinVal+0x46>
 8008794:	797b      	ldrb	r3, [r7, #5]
 8008796:	2b00      	cmp	r3, #0
 8008798:	d005      	beq.n	80087a6 <GPIO_SetPinVal+0x46>
	    Copy_Value == GPIO_PIN_OD_LOW ||  Copy_Value == GPIO_PIN_PULLUP || Copy_Value == GPIO_PIN_PULLDOWN))
 800879a:	797b      	ldrb	r3, [r7, #5]
 800879c:	2b01      	cmp	r3, #1
 800879e:	d002      	beq.n	80087a6 <GPIO_SetPinVal+0x46>
 80087a0:	797b      	ldrb	r3, [r7, #5]
 80087a2:	2b00      	cmp	r3, #0
 80087a4:	d167      	bne.n	8008876 <GPIO_SetPinVal+0x116>
	{
			/* Check port number */
			switch(Copy_Port)
 80087a6:	79fb      	ldrb	r3, [r7, #7]
 80087a8:	2b01      	cmp	r3, #1
 80087aa:	d022      	beq.n	80087f2 <GPIO_SetPinVal+0x92>
 80087ac:	2b02      	cmp	r3, #2
 80087ae:	d03e      	beq.n	800882e <GPIO_SetPinVal+0xce>
 80087b0:	2b00      	cmp	r3, #0
 80087b2:	d000      	beq.n	80087b6 <GPIO_SetPinVal+0x56>
						/* Set pin in BRR register */
						GPIOC->BRR = (1 << Copy_Pin);
					}
					break;
			}
	}
 80087b4:	e061      	b.n	800887a <GPIO_SetPinVal+0x11a>
					if(Copy_Value == GPIO_PIN_HIGH || Copy_Value == GPIO_PIN_PULLUP || Copy_Value == GPIO_PIN_OD_HIGH)
 80087b6:	797b      	ldrb	r3, [r7, #5]
 80087b8:	2b01      	cmp	r3, #1
 80087ba:	d005      	beq.n	80087c8 <GPIO_SetPinVal+0x68>
 80087bc:	797b      	ldrb	r3, [r7, #5]
 80087be:	2b01      	cmp	r3, #1
 80087c0:	d002      	beq.n	80087c8 <GPIO_SetPinVal+0x68>
 80087c2:	797b      	ldrb	r3, [r7, #5]
 80087c4:	2b01      	cmp	r3, #1
 80087c6:	d105      	bne.n	80087d4 <GPIO_SetPinVal+0x74>
						GPIOA->BSRR = (1 << Copy_Pin);
 80087c8:	79bb      	ldrb	r3, [r7, #6]
 80087ca:	2201      	movs	r2, #1
 80087cc:	409a      	lsls	r2, r3
 80087ce:	4b2e      	ldr	r3, [pc, #184]	; (8008888 <GPIO_SetPinVal+0x128>)
 80087d0:	611a      	str	r2, [r3, #16]
					break;
 80087d2:	e04a      	b.n	800886a <GPIO_SetPinVal+0x10a>
					else if(Copy_Value == GPIO_PIN_LOW || Copy_Value == GPIO_PIN_PULLDOWN || Copy_Value == GPIO_PIN_OD_LOW)
 80087d4:	797b      	ldrb	r3, [r7, #5]
 80087d6:	2b00      	cmp	r3, #0
 80087d8:	d005      	beq.n	80087e6 <GPIO_SetPinVal+0x86>
 80087da:	797b      	ldrb	r3, [r7, #5]
 80087dc:	2b00      	cmp	r3, #0
 80087de:	d002      	beq.n	80087e6 <GPIO_SetPinVal+0x86>
 80087e0:	797b      	ldrb	r3, [r7, #5]
 80087e2:	2b00      	cmp	r3, #0
 80087e4:	d141      	bne.n	800886a <GPIO_SetPinVal+0x10a>
						GPIOA->BRR = (1 << Copy_Pin);
 80087e6:	79bb      	ldrb	r3, [r7, #6]
 80087e8:	2201      	movs	r2, #1
 80087ea:	409a      	lsls	r2, r3
 80087ec:	4b26      	ldr	r3, [pc, #152]	; (8008888 <GPIO_SetPinVal+0x128>)
 80087ee:	615a      	str	r2, [r3, #20]
					break;
 80087f0:	e03b      	b.n	800886a <GPIO_SetPinVal+0x10a>
					if(Copy_Value == GPIO_PIN_HIGH || Copy_Value == GPIO_PIN_PULLUP || Copy_Value == GPIO_PIN_OD_HIGH)
 80087f2:	797b      	ldrb	r3, [r7, #5]
 80087f4:	2b01      	cmp	r3, #1
 80087f6:	d005      	beq.n	8008804 <GPIO_SetPinVal+0xa4>
 80087f8:	797b      	ldrb	r3, [r7, #5]
 80087fa:	2b01      	cmp	r3, #1
 80087fc:	d002      	beq.n	8008804 <GPIO_SetPinVal+0xa4>
 80087fe:	797b      	ldrb	r3, [r7, #5]
 8008800:	2b01      	cmp	r3, #1
 8008802:	d105      	bne.n	8008810 <GPIO_SetPinVal+0xb0>
						GPIOB->BSRR = (1 << Copy_Pin);
 8008804:	79bb      	ldrb	r3, [r7, #6]
 8008806:	2201      	movs	r2, #1
 8008808:	409a      	lsls	r2, r3
 800880a:	4b20      	ldr	r3, [pc, #128]	; (800888c <GPIO_SetPinVal+0x12c>)
 800880c:	611a      	str	r2, [r3, #16]
					break;
 800880e:	e02e      	b.n	800886e <GPIO_SetPinVal+0x10e>
					else if(Copy_Value == GPIO_PIN_LOW || Copy_Value == GPIO_PIN_PULLDOWN || Copy_Value == GPIO_PIN_OD_LOW)
 8008810:	797b      	ldrb	r3, [r7, #5]
 8008812:	2b00      	cmp	r3, #0
 8008814:	d005      	beq.n	8008822 <GPIO_SetPinVal+0xc2>
 8008816:	797b      	ldrb	r3, [r7, #5]
 8008818:	2b00      	cmp	r3, #0
 800881a:	d002      	beq.n	8008822 <GPIO_SetPinVal+0xc2>
 800881c:	797b      	ldrb	r3, [r7, #5]
 800881e:	2b00      	cmp	r3, #0
 8008820:	d125      	bne.n	800886e <GPIO_SetPinVal+0x10e>
						GPIOB->BRR = (1 << Copy_Pin);
 8008822:	79bb      	ldrb	r3, [r7, #6]
 8008824:	2201      	movs	r2, #1
 8008826:	409a      	lsls	r2, r3
 8008828:	4b18      	ldr	r3, [pc, #96]	; (800888c <GPIO_SetPinVal+0x12c>)
 800882a:	615a      	str	r2, [r3, #20]
					break;
 800882c:	e01f      	b.n	800886e <GPIO_SetPinVal+0x10e>
					if(Copy_Value == GPIO_PIN_HIGH || Copy_Value == GPIO_PIN_PULLUP || Copy_Value == GPIO_PIN_OD_HIGH)
 800882e:	797b      	ldrb	r3, [r7, #5]
 8008830:	2b01      	cmp	r3, #1
 8008832:	d005      	beq.n	8008840 <GPIO_SetPinVal+0xe0>
 8008834:	797b      	ldrb	r3, [r7, #5]
 8008836:	2b01      	cmp	r3, #1
 8008838:	d002      	beq.n	8008840 <GPIO_SetPinVal+0xe0>
 800883a:	797b      	ldrb	r3, [r7, #5]
 800883c:	2b01      	cmp	r3, #1
 800883e:	d105      	bne.n	800884c <GPIO_SetPinVal+0xec>
						GPIOC->BSRR = (1 << Copy_Pin);
 8008840:	79bb      	ldrb	r3, [r7, #6]
 8008842:	2201      	movs	r2, #1
 8008844:	409a      	lsls	r2, r3
 8008846:	4b12      	ldr	r3, [pc, #72]	; (8008890 <GPIO_SetPinVal+0x130>)
 8008848:	611a      	str	r2, [r3, #16]
					break;
 800884a:	e012      	b.n	8008872 <GPIO_SetPinVal+0x112>
					else if(Copy_Value == GPIO_PIN_LOW || Copy_Value == GPIO_PIN_PULLDOWN || Copy_Value == GPIO_PIN_OD_LOW)
 800884c:	797b      	ldrb	r3, [r7, #5]
 800884e:	2b00      	cmp	r3, #0
 8008850:	d005      	beq.n	800885e <GPIO_SetPinVal+0xfe>
 8008852:	797b      	ldrb	r3, [r7, #5]
 8008854:	2b00      	cmp	r3, #0
 8008856:	d002      	beq.n	800885e <GPIO_SetPinVal+0xfe>
 8008858:	797b      	ldrb	r3, [r7, #5]
 800885a:	2b00      	cmp	r3, #0
 800885c:	d109      	bne.n	8008872 <GPIO_SetPinVal+0x112>
						GPIOC->BRR = (1 << Copy_Pin);
 800885e:	79bb      	ldrb	r3, [r7, #6]
 8008860:	2201      	movs	r2, #1
 8008862:	409a      	lsls	r2, r3
 8008864:	4b0a      	ldr	r3, [pc, #40]	; (8008890 <GPIO_SetPinVal+0x130>)
 8008866:	615a      	str	r2, [r3, #20]
					break;
 8008868:	e003      	b.n	8008872 <GPIO_SetPinVal+0x112>
					break;
 800886a:	bf00      	nop
 800886c:	e005      	b.n	800887a <GPIO_SetPinVal+0x11a>
					break;
 800886e:	bf00      	nop
 8008870:	e003      	b.n	800887a <GPIO_SetPinVal+0x11a>
					break;
 8008872:	bf00      	nop
	}
 8008874:	e001      	b.n	800887a <GPIO_SetPinVal+0x11a>
	else
	{
		/* Function is not behaving as expected */
		Local_Status = RT_NOK;
 8008876:	2301      	movs	r3, #1
 8008878:	73fb      	strb	r3, [r7, #15]
	}

	return Local_Status;
 800887a:	7bfb      	ldrb	r3, [r7, #15]
}
 800887c:	4618      	mov	r0, r3
 800887e:	3714      	adds	r7, #20
 8008880:	46bd      	mov	sp, r7
 8008882:	bc80      	pop	{r7}
 8008884:	4770      	bx	lr
 8008886:	bf00      	nop
 8008888:	40010800 	.word	0x40010800
 800888c:	40010c00 	.word	0x40010c00
 8008890:	40011000 	.word	0x40011000

08008894 <SCB_ShiftInterruptVectorTable>:
/*--------------------------------------------------------------------------------*/
/* @Description	 : This function is intended to force a large system software	  */
/* 				   reset of all major components								  */
/*--------------------------------------------------------------------------------*/
ERROR_STATUS_t SCB_ShiftInterruptVectorTable(uint32_t Copy_VectorTableOffset)
{
 8008894:	b480      	push	{r7}
 8008896:	b085      	sub	sp, #20
 8008898:	af00      	add	r7, sp, #0
 800889a:	6078      	str	r0, [r7, #4]
	/* Local Variables Definitions */
	uint8_t Local_Status = RT_OK;
 800889c:	2300      	movs	r3, #0
 800889e:	73fb      	strb	r3, [r7, #15]

	/* Check if passed vector table offset is within the valid range */
	if((Copy_VectorTableOffset >= 0x00000000 && Copy_VectorTableOffset <= 0x3FFFFE00) &&
 80088a0:	687b      	ldr	r3, [r7, #4]
 80088a2:	4a09      	ldr	r2, [pc, #36]	; (80088c8 <SCB_ShiftInterruptVectorTable+0x34>)
 80088a4:	4293      	cmp	r3, r2
 80088a6:	d807      	bhi.n	80088b8 <SCB_ShiftInterruptVectorTable+0x24>
	   ((Copy_VectorTableOffset & 0x000000FF) == 0))
 80088a8:	687b      	ldr	r3, [r7, #4]
 80088aa:	b2db      	uxtb	r3, r3
	if((Copy_VectorTableOffset >= 0x00000000 && Copy_VectorTableOffset <= 0x3FFFFE00) &&
 80088ac:	2b00      	cmp	r3, #0
 80088ae:	d103      	bne.n	80088b8 <SCB_ShiftInterruptVectorTable+0x24>
	{
		SCB->VTOR = Copy_VectorTableOffset;
 80088b0:	4a06      	ldr	r2, [pc, #24]	; (80088cc <SCB_ShiftInterruptVectorTable+0x38>)
 80088b2:	687b      	ldr	r3, [r7, #4]
 80088b4:	6093      	str	r3, [r2, #8]
 80088b6:	e001      	b.n	80088bc <SCB_ShiftInterruptVectorTable+0x28>
	}
	else
	{
		/* Function is not behaving as expected */
		Local_Status = RT_NOK;
 80088b8:	2301      	movs	r3, #1
 80088ba:	73fb      	strb	r3, [r7, #15]
	}
	return Local_Status;
 80088bc:	7bfb      	ldrb	r3, [r7, #15]
}
 80088be:	4618      	mov	r0, r3
 80088c0:	3714      	adds	r7, #20
 80088c2:	46bd      	mov	sp, r7
 80088c4:	bc80      	pop	{r7}
 80088c6:	4770      	bx	lr
 80088c8:	3ffffe00 	.word	0x3ffffe00
 80088cc:	e000ed00 	.word	0xe000ed00

080088d0 <SERV_Delay_ms>:
/* @Return          : uint32_t  	        	      		        			  */
/*--------------------------------------------------------------------------------*/
/* @Description     : Function to block the processor for specified delay in ms	  */
/*--------------------------------------------------------------------------------*/
uint32_t SERV_Delay_ms(uint32_t Copy_Time)
{
 80088d0:	b480      	push	{r7}
 80088d2:	b085      	sub	sp, #20
 80088d4:	af00      	add	r7, sp, #0
 80088d6:	6078      	str	r0, [r7, #4]
	uint32_t Local_Ticks = (500 * Copy_Time);
 80088d8:	687b      	ldr	r3, [r7, #4]
 80088da:	f44f 72fa 	mov.w	r2, #500	; 0x1f4
 80088de:	fb02 f303 	mul.w	r3, r2, r3
 80088e2:	60bb      	str	r3, [r7, #8]
	uint32_t Local_TicksCounter;

	for(Local_TicksCounter = 0 ; Local_TicksCounter < Local_Ticks ;Local_TicksCounter++)
 80088e4:	2300      	movs	r3, #0
 80088e6:	60fb      	str	r3, [r7, #12]
 80088e8:	e003      	b.n	80088f2 <SERV_Delay_ms+0x22>
	{
		__asm("NOP");
 80088ea:	bf00      	nop
	for(Local_TicksCounter = 0 ; Local_TicksCounter < Local_Ticks ;Local_TicksCounter++)
 80088ec:	68fb      	ldr	r3, [r7, #12]
 80088ee:	3301      	adds	r3, #1
 80088f0:	60fb      	str	r3, [r7, #12]
 80088f2:	68fa      	ldr	r2, [r7, #12]
 80088f4:	68bb      	ldr	r3, [r7, #8]
 80088f6:	429a      	cmp	r2, r3
 80088f8:	d3f7      	bcc.n	80088ea <SERV_Delay_ms+0x1a>
	}
	return Local_TicksCounter;
 80088fa:	68fb      	ldr	r3, [r7, #12]
}
 80088fc:	4618      	mov	r0, r3
 80088fe:	3714      	adds	r7, #20
 8008900:	46bd      	mov	sp, r7
 8008902:	bc80      	pop	{r7}
 8008904:	4770      	bx	lr
	...

08008908 <main>:
/**
 * @brief  The application entry point.
 * @retval int
 */
int main(void)
{
 8008908:	b580      	push	{r7, lr}
 800890a:	b082      	sub	sp, #8
 800890c:	af00      	add	r7, sp, #0
/* Local variables: */
	uint8_t Flag_once = 1;
 800890e:	2301      	movs	r3, #1
 8008910:	71fb      	strb	r3, [r7, #7]

	/* CAN RX header parameters */
	RxHeader.DLC = 1;
 8008912:	4b25      	ldr	r3, [pc, #148]	; (80089a8 <main+0xa0>)
 8008914:	2201      	movs	r2, #1
 8008916:	611a      	str	r2, [r3, #16]
	RxHeader.IDE = CAN_ID_STD;
 8008918:	4b23      	ldr	r3, [pc, #140]	; (80089a8 <main+0xa0>)
 800891a:	2200      	movs	r2, #0
 800891c:	609a      	str	r2, [r3, #8]
	RxHeader.RTR = CAN_RTR_DATA;
 800891e:	4b22      	ldr	r3, [pc, #136]	; (80089a8 <main+0xa0>)
 8008920:	2200      	movs	r2, #0
 8008922:	60da      	str	r2, [r3, #12]
	RxHeader.StdId = 0x100;
 8008924:	4b20      	ldr	r3, [pc, #128]	; (80089a8 <main+0xa0>)
 8008926:	f44f 7280 	mov.w	r2, #256	; 0x100
 800892a:	601a      	str	r2, [r3, #0]

/* MCU Configuration--------------------------------------------------------*/
	/* Reset of all peripherals, Initializes the Flash interface and the Systick. */
	HAL_Init();
 800892c:	f000 fa52 	bl	8008dd4 <HAL_Init>

	/* Initialize all configured peripherals */
	MX_GPIO_Init();
 8008930:	f000 f89a 	bl	8008a68 <MX_GPIO_Init>
/* CAN: */
	/* initializing the CAN driver. */
	MX_CAN_Init();
 8008934:	f000 f846 	bl	80089c4 <MX_CAN_Init>
	/* Start the CAN driver */
	HAL_CAN_Start(&hcan);
 8008938:	481c      	ldr	r0, [pc, #112]	; (80089ac <main+0xa4>)
 800893a:	f000 fcb1 	bl	80092a0 <HAL_CAN_Start>
	/* Enable the CAN interrupt mode */
	HAL_CAN_ActivateNotification(&hcan, CAN_IT_RX_FIFO0_MSG_PENDING);
 800893e:	2102      	movs	r1, #2
 8008940:	481a      	ldr	r0, [pc, #104]	; (80089ac <main+0xa4>)
 8008942:	f000 fe02 	bl	800954a <HAL_CAN_ActivateNotification>

/* LCD: */
	/* initialize the LCD */
	CLCD_Init();
 8008946:	f7ff fc01 	bl	800814c <CLCD_Init>
	/* clear the LCD */
	CLCD_ClearDisplay();
 800894a:	f7ff fdb8 	bl	80084be <CLCD_ClearDisplay>
	/* write the string on the LCD */
	CLCD_WriteString("App_1");
 800894e:	4818      	ldr	r0, [pc, #96]	; (80089b0 <main+0xa8>)
 8008950:	f7ff fdc3 	bl	80084da <CLCD_WriteString>

/* Super loop */
	while (1)
	{
		/* if the button is pressed */
		if(FLAG_buttonPressed)
 8008954:	4b17      	ldr	r3, [pc, #92]	; (80089b4 <main+0xac>)
 8008956:	781b      	ldrb	r3, [r3, #0]
 8008958:	2b00      	cmp	r3, #0
 800895a:	d005      	beq.n	8008968 <main+0x60>
		{
			/* delay for debouncing */
			HAL_Delay(100);
 800895c:	2064      	movs	r0, #100	; 0x64
 800895e:	f000 fab9 	bl	8008ed4 <HAL_Delay>
			/* jump to the bootloader */
			JumpToBootLoader();
 8008962:	f000 f8ef 	bl	8008b44 <JumpToBootLoader>
 8008966:	e7f5      	b.n	8008954 <main+0x4c>
		}
		else
		{
			/* if the CAN flag is raised */
			if(Flag_CAN)
 8008968:	4b13      	ldr	r3, [pc, #76]	; (80089b8 <main+0xb0>)
 800896a:	781b      	ldrb	r3, [r3, #0]
 800896c:	2b00      	cmp	r3, #0
 800896e:	d0f1      	beq.n	8008954 <main+0x4c>
			{
				if(Flag_once){
 8008970:	79fb      	ldrb	r3, [r7, #7]
 8008972:	2b00      	cmp	r3, #0
 8008974:	d00d      	beq.n	8008992 <main+0x8a>
					Flag_once = 0;
 8008976:	2300      	movs	r3, #0
 8008978:	71fb      	strb	r3, [r7, #7]
					/* clear the LCD */
					CLCD_ClearDisplay();
 800897a:	f7ff fda0 	bl	80084be <CLCD_ClearDisplay>
					/* write the string on the LCD */
					CLCD_WriteString("available update");
 800897e:	480f      	ldr	r0, [pc, #60]	; (80089bc <main+0xb4>)
 8008980:	f7ff fdab 	bl	80084da <CLCD_WriteString>
					/* moving cursor to the second raw */
					CLCD_MoveCursor(1, 0);
 8008984:	2100      	movs	r1, #0
 8008986:	2001      	movs	r0, #1
 8008988:	f7ff fdd0 	bl	800852c <CLCD_MoveCursor>
					/* write the string on the LCD */
					CLCD_WriteString("press the button");
 800898c:	480c      	ldr	r0, [pc, #48]	; (80089c0 <main+0xb8>)
 800898e:	f7ff fda4 	bl	80084da <CLCD_WriteString>
				}
				if(FLAG_buttonPressed){
 8008992:	4b08      	ldr	r3, [pc, #32]	; (80089b4 <main+0xac>)
 8008994:	781b      	ldrb	r3, [r3, #0]
 8008996:	2b00      	cmp	r3, #0
 8008998:	d0dc      	beq.n	8008954 <main+0x4c>
					HAL_Delay(100);
 800899a:	2064      	movs	r0, #100	; 0x64
 800899c:	f000 fa9a 	bl	8008ed4 <HAL_Delay>
					JumpToBootLoader();
 80089a0:	f000 f8d0 	bl	8008b44 <JumpToBootLoader>
		if(FLAG_buttonPressed)
 80089a4:	e7d6      	b.n	8008954 <main+0x4c>
 80089a6:	bf00      	nop
 80089a8:	2000005c 	.word	0x2000005c
 80089ac:	20000030 	.word	0x20000030
 80089b0:	08009f94 	.word	0x08009f94
 80089b4:	20000029 	.word	0x20000029
 80089b8:	20000028 	.word	0x20000028
 80089bc:	08009f9c 	.word	0x08009f9c
 80089c0:	08009fb0 	.word	0x08009fb0

080089c4 <MX_CAN_Init>:
 * @brief CAN Initialization Function
 * @param None
 * @retval None
 */
static void MX_CAN_Init(void)
{
 80089c4:	b580      	push	{r7, lr}
 80089c6:	b08a      	sub	sp, #40	; 0x28
 80089c8:	af00      	add	r7, sp, #0
	/* USER CODE END CAN_Init 0 */

	/* USER CODE BEGIN CAN_Init 1 */

	/* USER CODE END CAN_Init 1 */
	hcan.Instance = CAN1;
 80089ca:	4b25      	ldr	r3, [pc, #148]	; (8008a60 <MX_CAN_Init+0x9c>)
 80089cc:	4a25      	ldr	r2, [pc, #148]	; (8008a64 <MX_CAN_Init+0xa0>)
 80089ce:	601a      	str	r2, [r3, #0]
	hcan.Init.Prescaler = 16;
 80089d0:	4b23      	ldr	r3, [pc, #140]	; (8008a60 <MX_CAN_Init+0x9c>)
 80089d2:	2210      	movs	r2, #16
 80089d4:	605a      	str	r2, [r3, #4]
	hcan.Init.Mode = CAN_MODE_NORMAL;
 80089d6:	4b22      	ldr	r3, [pc, #136]	; (8008a60 <MX_CAN_Init+0x9c>)
 80089d8:	2200      	movs	r2, #0
 80089da:	609a      	str	r2, [r3, #8]
	hcan.Init.SyncJumpWidth = CAN_SJW_1TQ;
 80089dc:	4b20      	ldr	r3, [pc, #128]	; (8008a60 <MX_CAN_Init+0x9c>)
 80089de:	2200      	movs	r2, #0
 80089e0:	60da      	str	r2, [r3, #12]
	hcan.Init.TimeSeg1 = CAN_BS1_2TQ;
 80089e2:	4b1f      	ldr	r3, [pc, #124]	; (8008a60 <MX_CAN_Init+0x9c>)
 80089e4:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 80089e8:	611a      	str	r2, [r3, #16]
	hcan.Init.TimeSeg2 = CAN_BS2_1TQ;
 80089ea:	4b1d      	ldr	r3, [pc, #116]	; (8008a60 <MX_CAN_Init+0x9c>)
 80089ec:	2200      	movs	r2, #0
 80089ee:	615a      	str	r2, [r3, #20]
	hcan.Init.TimeTriggeredMode = DISABLE;
 80089f0:	4b1b      	ldr	r3, [pc, #108]	; (8008a60 <MX_CAN_Init+0x9c>)
 80089f2:	2200      	movs	r2, #0
 80089f4:	761a      	strb	r2, [r3, #24]
	hcan.Init.AutoBusOff = DISABLE;
 80089f6:	4b1a      	ldr	r3, [pc, #104]	; (8008a60 <MX_CAN_Init+0x9c>)
 80089f8:	2200      	movs	r2, #0
 80089fa:	765a      	strb	r2, [r3, #25]
	hcan.Init.AutoWakeUp = DISABLE;
 80089fc:	4b18      	ldr	r3, [pc, #96]	; (8008a60 <MX_CAN_Init+0x9c>)
 80089fe:	2200      	movs	r2, #0
 8008a00:	769a      	strb	r2, [r3, #26]
	hcan.Init.AutoRetransmission = DISABLE;
 8008a02:	4b17      	ldr	r3, [pc, #92]	; (8008a60 <MX_CAN_Init+0x9c>)
 8008a04:	2200      	movs	r2, #0
 8008a06:	76da      	strb	r2, [r3, #27]
	hcan.Init.ReceiveFifoLocked = DISABLE;
 8008a08:	4b15      	ldr	r3, [pc, #84]	; (8008a60 <MX_CAN_Init+0x9c>)
 8008a0a:	2200      	movs	r2, #0
 8008a0c:	771a      	strb	r2, [r3, #28]
	hcan.Init.TransmitFifoPriority = DISABLE;
 8008a0e:	4b14      	ldr	r3, [pc, #80]	; (8008a60 <MX_CAN_Init+0x9c>)
 8008a10:	2200      	movs	r2, #0
 8008a12:	775a      	strb	r2, [r3, #29]
	if (HAL_CAN_Init(&hcan) != HAL_OK)
 8008a14:	4812      	ldr	r0, [pc, #72]	; (8008a60 <MX_CAN_Init+0x9c>)
 8008a16:	f000 fa7f 	bl	8008f18 <HAL_CAN_Init>
 8008a1a:	4603      	mov	r3, r0
 8008a1c:	2b00      	cmp	r3, #0
 8008a1e:	d001      	beq.n	8008a24 <MX_CAN_Init+0x60>
	{
		Error_Handler();
 8008a20:	f000 f8d4 	bl	8008bcc <Error_Handler>
	}
	/* USER CODE BEGIN CAN_Init 2 */
	CAN_FilterTypeDef canfilterconfig;


	canfilterconfig.FilterActivation = CAN_FILTER_ENABLE;
 8008a24:	2301      	movs	r3, #1
 8008a26:	623b      	str	r3, [r7, #32]
	canfilterconfig.FilterBank = 10;  // anything between 0 to SlaveStartFilterBank
 8008a28:	230a      	movs	r3, #10
 8008a2a:	617b      	str	r3, [r7, #20]
	canfilterconfig.FilterFIFOAssignment = CAN_RX_FIFO0;
 8008a2c:	2300      	movs	r3, #0
 8008a2e:	613b      	str	r3, [r7, #16]
	canfilterconfig.FilterIdHigh = 0x0000;
 8008a30:	2300      	movs	r3, #0
 8008a32:	603b      	str	r3, [r7, #0]
	canfilterconfig.FilterIdLow = 0x0000;
 8008a34:	2300      	movs	r3, #0
 8008a36:	607b      	str	r3, [r7, #4]
	canfilterconfig.FilterMaskIdHigh = 0x0000;
 8008a38:	2300      	movs	r3, #0
 8008a3a:	60bb      	str	r3, [r7, #8]
	canfilterconfig.FilterMaskIdLow = 0x0000;
 8008a3c:	2300      	movs	r3, #0
 8008a3e:	60fb      	str	r3, [r7, #12]
	canfilterconfig.FilterMode = CAN_FILTERMODE_IDMASK;
 8008a40:	2300      	movs	r3, #0
 8008a42:	61bb      	str	r3, [r7, #24]
	canfilterconfig.FilterScale = CAN_FILTERSCALE_32BIT;
 8008a44:	2301      	movs	r3, #1
 8008a46:	61fb      	str	r3, [r7, #28]
	canfilterconfig.SlaveStartFilterBank = 0;  // 13 to 27 are assigned to slave CAN (CAN 2) OR 0 to 12 are assigned to CAN1
 8008a48:	2300      	movs	r3, #0
 8008a4a:	627b      	str	r3, [r7, #36]	; 0x24

	HAL_CAN_ConfigFilter(&hcan, &canfilterconfig);
 8008a4c:	463b      	mov	r3, r7
 8008a4e:	4619      	mov	r1, r3
 8008a50:	4803      	ldr	r0, [pc, #12]	; (8008a60 <MX_CAN_Init+0x9c>)
 8008a52:	f000 fb5c 	bl	800910e <HAL_CAN_ConfigFilter>

	/* USER CODE END CAN_Init 2 */

}
 8008a56:	bf00      	nop
 8008a58:	3728      	adds	r7, #40	; 0x28
 8008a5a:	46bd      	mov	sp, r7
 8008a5c:	bd80      	pop	{r7, pc}
 8008a5e:	bf00      	nop
 8008a60:	20000030 	.word	0x20000030
 8008a64:	40006400 	.word	0x40006400

08008a68 <MX_GPIO_Init>:
  * @brief GPIO Initialization Function
  * @param None
  * @retval None
  */
static void MX_GPIO_Init(void)
{
 8008a68:	b580      	push	{r7, lr}
 8008a6a:	b086      	sub	sp, #24
 8008a6c:	af00      	add	r7, sp, #0
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8008a6e:	f107 0308 	add.w	r3, r7, #8
 8008a72:	2200      	movs	r2, #0
 8008a74:	601a      	str	r2, [r3, #0]
 8008a76:	605a      	str	r2, [r3, #4]
 8008a78:	609a      	str	r2, [r3, #8]
 8008a7a:	60da      	str	r2, [r3, #12]

  /* GPIO Ports Clock Enable */
  __HAL_RCC_GPIOA_CLK_ENABLE();
 8008a7c:	4b2d      	ldr	r3, [pc, #180]	; (8008b34 <MX_GPIO_Init+0xcc>)
 8008a7e:	699b      	ldr	r3, [r3, #24]
 8008a80:	4a2c      	ldr	r2, [pc, #176]	; (8008b34 <MX_GPIO_Init+0xcc>)
 8008a82:	f043 0304 	orr.w	r3, r3, #4
 8008a86:	6193      	str	r3, [r2, #24]
 8008a88:	4b2a      	ldr	r3, [pc, #168]	; (8008b34 <MX_GPIO_Init+0xcc>)
 8008a8a:	699b      	ldr	r3, [r3, #24]
 8008a8c:	f003 0304 	and.w	r3, r3, #4
 8008a90:	607b      	str	r3, [r7, #4]
 8008a92:	687b      	ldr	r3, [r7, #4]
  __HAL_RCC_GPIOB_CLK_ENABLE();
 8008a94:	4b27      	ldr	r3, [pc, #156]	; (8008b34 <MX_GPIO_Init+0xcc>)
 8008a96:	699b      	ldr	r3, [r3, #24]
 8008a98:	4a26      	ldr	r2, [pc, #152]	; (8008b34 <MX_GPIO_Init+0xcc>)
 8008a9a:	f043 0308 	orr.w	r3, r3, #8
 8008a9e:	6193      	str	r3, [r2, #24]
 8008aa0:	4b24      	ldr	r3, [pc, #144]	; (8008b34 <MX_GPIO_Init+0xcc>)
 8008aa2:	699b      	ldr	r3, [r3, #24]
 8008aa4:	f003 0308 	and.w	r3, r3, #8
 8008aa8:	603b      	str	r3, [r7, #0]
 8008aaa:	683b      	ldr	r3, [r7, #0]

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOA, GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_8|GPIO_PIN_9, GPIO_PIN_RESET);
 8008aac:	2200      	movs	r2, #0
 8008aae:	f240 3106 	movw	r1, #774	; 0x306
 8008ab2:	4821      	ldr	r0, [pc, #132]	; (8008b38 <MX_GPIO_Init+0xd0>)
 8008ab4:	f001 f9f4 	bl	8009ea0 <HAL_GPIO_WritePin>

  /*Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET);
 8008ab8:	2200      	movs	r2, #0
 8008aba:	f44f 4170 	mov.w	r1, #61440	; 0xf000
 8008abe:	481f      	ldr	r0, [pc, #124]	; (8008b3c <MX_GPIO_Init+0xd4>)
 8008ac0:	f001 f9ee 	bl	8009ea0 <HAL_GPIO_WritePin>

  /*Configure GPIO pins : PA1 PA2 PA8 PA9 */
  GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_8|GPIO_PIN_9;
 8008ac4:	f240 3306 	movw	r3, #774	; 0x306
 8008ac8:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8008aca:	2301      	movs	r3, #1
 8008acc:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008ace:	2300      	movs	r3, #0
 8008ad0:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8008ad2:	2302      	movs	r3, #2
 8008ad4:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8008ad6:	f107 0308 	add.w	r3, r7, #8
 8008ada:	4619      	mov	r1, r3
 8008adc:	4816      	ldr	r0, [pc, #88]	; (8008b38 <MX_GPIO_Init+0xd0>)
 8008ade:	f001 f885 	bl	8009bec <HAL_GPIO_Init>

  /*Configure GPIO pin : PB11 */
  GPIO_InitStruct.Pin = GPIO_PIN_11;
 8008ae2:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8008ae6:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Mode = GPIO_MODE_IT_FALLING;
 8008ae8:	4b15      	ldr	r3, [pc, #84]	; (8008b40 <MX_GPIO_Init+0xd8>)
 8008aea:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008aec:	2300      	movs	r3, #0
 8008aee:	613b      	str	r3, [r7, #16]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8008af0:	f107 0308 	add.w	r3, r7, #8
 8008af4:	4619      	mov	r1, r3
 8008af6:	4811      	ldr	r0, [pc, #68]	; (8008b3c <MX_GPIO_Init+0xd4>)
 8008af8:	f001 f878 	bl	8009bec <HAL_GPIO_Init>

  /*Configure GPIO pins : PB12 PB13 PB14 PB15 */
  GPIO_InitStruct.Pin = GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
 8008afc:	f44f 4370 	mov.w	r3, #61440	; 0xf000
 8008b00:	60bb      	str	r3, [r7, #8]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8008b02:	2301      	movs	r3, #1
 8008b04:	60fb      	str	r3, [r7, #12]
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008b06:	2300      	movs	r3, #0
 8008b08:	613b      	str	r3, [r7, #16]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8008b0a:	2302      	movs	r3, #2
 8008b0c:	617b      	str	r3, [r7, #20]
  HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8008b0e:	f107 0308 	add.w	r3, r7, #8
 8008b12:	4619      	mov	r1, r3
 8008b14:	4809      	ldr	r0, [pc, #36]	; (8008b3c <MX_GPIO_Init+0xd4>)
 8008b16:	f001 f869 	bl	8009bec <HAL_GPIO_Init>

  /* EXTI interrupt init*/
  HAL_NVIC_SetPriority(EXTI15_10_IRQn, 0, 0);
 8008b1a:	2200      	movs	r2, #0
 8008b1c:	2100      	movs	r1, #0
 8008b1e:	2028      	movs	r0, #40	; 0x28
 8008b20:	f001 f82d 	bl	8009b7e <HAL_NVIC_SetPriority>
  HAL_NVIC_EnableIRQ(EXTI15_10_IRQn);
 8008b24:	2028      	movs	r0, #40	; 0x28
 8008b26:	f001 f846 	bl	8009bb6 <HAL_NVIC_EnableIRQ>

}
 8008b2a:	bf00      	nop
 8008b2c:	3718      	adds	r7, #24
 8008b2e:	46bd      	mov	sp, r7
 8008b30:	bd80      	pop	{r7, pc}
 8008b32:	bf00      	nop
 8008b34:	40021000 	.word	0x40021000
 8008b38:	40010800 	.word	0x40010800
 8008b3c:	40010c00 	.word	0x40010c00
 8008b40:	10210000 	.word	0x10210000

08008b44 <JumpToBootLoader>:

/* USER CODE BEGIN 4 */

void JumpToBootLoader(void){
 8008b44:	b580      	push	{r7, lr}
 8008b46:	af00      	add	r7, sp, #0
	/* shift the vector table to that of APP_1 */
	SCB_ShiftInterruptVectorTable(0x08000000);
 8008b48:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
 8008b4c:	f7ff fea2 	bl	8008894 <SCB_ShiftInterruptVectorTable>
	/* assign the address to call variable to the address of APP_1 */
	addr_to_call = *(fun_ptr*)(0x08000004);
 8008b50:	4b05      	ldr	r3, [pc, #20]	; (8008b68 <JumpToBootLoader+0x24>)
 8008b52:	681b      	ldr	r3, [r3, #0]
 8008b54:	4a05      	ldr	r2, [pc, #20]	; (8008b6c <JumpToBootLoader+0x28>)
 8008b56:	6013      	str	r3, [r2, #0]
	/* deinitializing the HAL */
	HAL_DeInit();
 8008b58:	f000 f952 	bl	8008e00 <HAL_DeInit>
	/* jump to APP_1 by calling this pointer */
	addr_to_call();
 8008b5c:	4b03      	ldr	r3, [pc, #12]	; (8008b6c <JumpToBootLoader+0x28>)
 8008b5e:	681b      	ldr	r3, [r3, #0]
 8008b60:	4798      	blx	r3
}
 8008b62:	bf00      	nop
 8008b64:	bd80      	pop	{r7, pc}
 8008b66:	bf00      	nop
 8008b68:	08000004 	.word	0x08000004
 8008b6c:	2000002c 	.word	0x2000002c

08008b70 <HAL_CAN_RxFifo0MsgPendingCallback>:
 * return: void
 *
 * description: CAN callback function
 ***************************************************************/
void HAL_CAN_RxFifo0MsgPendingCallback(CAN_HandleTypeDef *hcan)
{
 8008b70:	b580      	push	{r7, lr}
 8008b72:	b082      	sub	sp, #8
 8008b74:	af00      	add	r7, sp, #0
 8008b76:	6078      	str	r0, [r7, #4]
	/* raise the CAN flag */
	Flag_CAN = 1;
 8008b78:	4b08      	ldr	r3, [pc, #32]	; (8008b9c <HAL_CAN_RxFifo0MsgPendingCallback+0x2c>)
 8008b7a:	2201      	movs	r2, #1
 8008b7c:	701a      	strb	r2, [r3, #0]
	/* toggle a led that indicates a reception*/
	HAL_GPIO_TogglePin(GPIOA, GPIO_PIN_1);
 8008b7e:	2102      	movs	r1, #2
 8008b80:	4807      	ldr	r0, [pc, #28]	; (8008ba0 <HAL_CAN_RxFifo0MsgPendingCallback+0x30>)
 8008b82:	f001 f9a5 	bl	8009ed0 <HAL_GPIO_TogglePin>
	/* receive in the CAN RX buffer */
	HAL_CAN_GetRxMessage(hcan, CAN_RX_FIFO0, &RxHeader, &CAN_RxBuffer);
 8008b86:	4b07      	ldr	r3, [pc, #28]	; (8008ba4 <HAL_CAN_RxFifo0MsgPendingCallback+0x34>)
 8008b88:	4a07      	ldr	r2, [pc, #28]	; (8008ba8 <HAL_CAN_RxFifo0MsgPendingCallback+0x38>)
 8008b8a:	2100      	movs	r1, #0
 8008b8c:	6878      	ldr	r0, [r7, #4]
 8008b8e:	f000 fbcb 	bl	8009328 <HAL_CAN_GetRxMessage>

}
 8008b92:	bf00      	nop
 8008b94:	3708      	adds	r7, #8
 8008b96:	46bd      	mov	sp, r7
 8008b98:	bd80      	pop	{r7, pc}
 8008b9a:	bf00      	nop
 8008b9c:	20000028 	.word	0x20000028
 8008ba0:	40010800 	.word	0x40010800
 8008ba4:	20000058 	.word	0x20000058
 8008ba8:	2000005c 	.word	0x2000005c

08008bac <HAL_GPIO_EXTI_Callback>:
 *
 * return: void
 *
 * description: External callback function
 ***************************************************************/
void HAL_GPIO_EXTI_Callback(uint16_t GPIO_Pins){
 8008bac:	b480      	push	{r7}
 8008bae:	b083      	sub	sp, #12
 8008bb0:	af00      	add	r7, sp, #0
 8008bb2:	4603      	mov	r3, r0
 8008bb4:	80fb      	strh	r3, [r7, #6]
	/* raise the switch flag */
	FLAG_buttonPressed = 1;
 8008bb6:	4b04      	ldr	r3, [pc, #16]	; (8008bc8 <HAL_GPIO_EXTI_Callback+0x1c>)
 8008bb8:	2201      	movs	r2, #1
 8008bba:	701a      	strb	r2, [r3, #0]
}
 8008bbc:	bf00      	nop
 8008bbe:	370c      	adds	r7, #12
 8008bc0:	46bd      	mov	sp, r7
 8008bc2:	bc80      	pop	{r7}
 8008bc4:	4770      	bx	lr
 8008bc6:	bf00      	nop
 8008bc8:	20000029 	.word	0x20000029

08008bcc <Error_Handler>:
/**
 * @brief  This function is executed in case of error occurrence.
 * @retval None
 */
void Error_Handler(void)
{
 8008bcc:	b480      	push	{r7}
 8008bce:	af00      	add	r7, sp, #0
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8008bd0:	b672      	cpsid	i
	/* USER CODE BEGIN Error_Handler_Debug */
	/* User can add his own implementation to report the HAL error return state */
	__disable_irq();
	while (1)
 8008bd2:	e7fe      	b.n	8008bd2 <Error_Handler+0x6>

08008bd4 <HAL_MspInit>:
/* USER CODE END 0 */
/**
  * Initializes the Global MSP.
  */
void HAL_MspInit(void)
{
 8008bd4:	b480      	push	{r7}
 8008bd6:	b085      	sub	sp, #20
 8008bd8:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_AFIO_CLK_ENABLE();
 8008bda:	4b15      	ldr	r3, [pc, #84]	; (8008c30 <HAL_MspInit+0x5c>)
 8008bdc:	699b      	ldr	r3, [r3, #24]
 8008bde:	4a14      	ldr	r2, [pc, #80]	; (8008c30 <HAL_MspInit+0x5c>)
 8008be0:	f043 0301 	orr.w	r3, r3, #1
 8008be4:	6193      	str	r3, [r2, #24]
 8008be6:	4b12      	ldr	r3, [pc, #72]	; (8008c30 <HAL_MspInit+0x5c>)
 8008be8:	699b      	ldr	r3, [r3, #24]
 8008bea:	f003 0301 	and.w	r3, r3, #1
 8008bee:	60bb      	str	r3, [r7, #8]
 8008bf0:	68bb      	ldr	r3, [r7, #8]
  __HAL_RCC_PWR_CLK_ENABLE();
 8008bf2:	4b0f      	ldr	r3, [pc, #60]	; (8008c30 <HAL_MspInit+0x5c>)
 8008bf4:	69db      	ldr	r3, [r3, #28]
 8008bf6:	4a0e      	ldr	r2, [pc, #56]	; (8008c30 <HAL_MspInit+0x5c>)
 8008bf8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8008bfc:	61d3      	str	r3, [r2, #28]
 8008bfe:	4b0c      	ldr	r3, [pc, #48]	; (8008c30 <HAL_MspInit+0x5c>)
 8008c00:	69db      	ldr	r3, [r3, #28]
 8008c02:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8008c06:	607b      	str	r3, [r7, #4]
 8008c08:	687b      	ldr	r3, [r7, #4]

  /* System interrupt init*/

  /** NOJTAG: JTAG-DP Disabled and SW-DP Enabled
  */
  __HAL_AFIO_REMAP_SWJ_NOJTAG();
 8008c0a:	4b0a      	ldr	r3, [pc, #40]	; (8008c34 <HAL_MspInit+0x60>)
 8008c0c:	685b      	ldr	r3, [r3, #4]
 8008c0e:	60fb      	str	r3, [r7, #12]
 8008c10:	68fb      	ldr	r3, [r7, #12]
 8008c12:	f023 63e0 	bic.w	r3, r3, #117440512	; 0x7000000
 8008c16:	60fb      	str	r3, [r7, #12]
 8008c18:	68fb      	ldr	r3, [r7, #12]
 8008c1a:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8008c1e:	60fb      	str	r3, [r7, #12]
 8008c20:	4a04      	ldr	r2, [pc, #16]	; (8008c34 <HAL_MspInit+0x60>)
 8008c22:	68fb      	ldr	r3, [r7, #12]
 8008c24:	6053      	str	r3, [r2, #4]

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8008c26:	bf00      	nop
 8008c28:	3714      	adds	r7, #20
 8008c2a:	46bd      	mov	sp, r7
 8008c2c:	bc80      	pop	{r7}
 8008c2e:	4770      	bx	lr
 8008c30:	40021000 	.word	0x40021000
 8008c34:	40010000 	.word	0x40010000

08008c38 <HAL_CAN_MspInit>:
* This function configures the hardware resources used in this example
* @param hcan: CAN handle pointer
* @retval None
*/
void HAL_CAN_MspInit(CAN_HandleTypeDef* hcan)
{
 8008c38:	b580      	push	{r7, lr}
 8008c3a:	b088      	sub	sp, #32
 8008c3c:	af00      	add	r7, sp, #0
 8008c3e:	6078      	str	r0, [r7, #4]
  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8008c40:	f107 0310 	add.w	r3, r7, #16
 8008c44:	2200      	movs	r2, #0
 8008c46:	601a      	str	r2, [r3, #0]
 8008c48:	605a      	str	r2, [r3, #4]
 8008c4a:	609a      	str	r2, [r3, #8]
 8008c4c:	60da      	str	r2, [r3, #12]
  if(hcan->Instance==CAN1)
 8008c4e:	687b      	ldr	r3, [r7, #4]
 8008c50:	681b      	ldr	r3, [r3, #0]
 8008c52:	4a24      	ldr	r2, [pc, #144]	; (8008ce4 <HAL_CAN_MspInit+0xac>)
 8008c54:	4293      	cmp	r3, r2
 8008c56:	d141      	bne.n	8008cdc <HAL_CAN_MspInit+0xa4>
  {
  /* USER CODE BEGIN CAN1_MspInit 0 */

  /* USER CODE END CAN1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_CAN1_CLK_ENABLE();
 8008c58:	4b23      	ldr	r3, [pc, #140]	; (8008ce8 <HAL_CAN_MspInit+0xb0>)
 8008c5a:	69db      	ldr	r3, [r3, #28]
 8008c5c:	4a22      	ldr	r2, [pc, #136]	; (8008ce8 <HAL_CAN_MspInit+0xb0>)
 8008c5e:	f043 7300 	orr.w	r3, r3, #33554432	; 0x2000000
 8008c62:	61d3      	str	r3, [r2, #28]
 8008c64:	4b20      	ldr	r3, [pc, #128]	; (8008ce8 <HAL_CAN_MspInit+0xb0>)
 8008c66:	69db      	ldr	r3, [r3, #28]
 8008c68:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 8008c6c:	60fb      	str	r3, [r7, #12]
 8008c6e:	68fb      	ldr	r3, [r7, #12]

    __HAL_RCC_GPIOA_CLK_ENABLE();
 8008c70:	4b1d      	ldr	r3, [pc, #116]	; (8008ce8 <HAL_CAN_MspInit+0xb0>)
 8008c72:	699b      	ldr	r3, [r3, #24]
 8008c74:	4a1c      	ldr	r2, [pc, #112]	; (8008ce8 <HAL_CAN_MspInit+0xb0>)
 8008c76:	f043 0304 	orr.w	r3, r3, #4
 8008c7a:	6193      	str	r3, [r2, #24]
 8008c7c:	4b1a      	ldr	r3, [pc, #104]	; (8008ce8 <HAL_CAN_MspInit+0xb0>)
 8008c7e:	699b      	ldr	r3, [r3, #24]
 8008c80:	f003 0304 	and.w	r3, r3, #4
 8008c84:	60bb      	str	r3, [r7, #8]
 8008c86:	68bb      	ldr	r3, [r7, #8]
    /**CAN GPIO Configuration
    PA11     ------> CAN_RX
    PA12     ------> CAN_TX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_11;
 8008c88:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8008c8c:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
 8008c8e:	2300      	movs	r3, #0
 8008c90:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Pull = GPIO_NOPULL;
 8008c92:	2300      	movs	r3, #0
 8008c94:	61bb      	str	r3, [r7, #24]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8008c96:	f107 0310 	add.w	r3, r7, #16
 8008c9a:	4619      	mov	r1, r3
 8008c9c:	4813      	ldr	r0, [pc, #76]	; (8008cec <HAL_CAN_MspInit+0xb4>)
 8008c9e:	f000 ffa5 	bl	8009bec <HAL_GPIO_Init>

    GPIO_InitStruct.Pin = GPIO_PIN_12;
 8008ca2:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8008ca6:	613b      	str	r3, [r7, #16]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8008ca8:	2302      	movs	r3, #2
 8008caa:	617b      	str	r3, [r7, #20]
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_HIGH;
 8008cac:	2303      	movs	r3, #3
 8008cae:	61fb      	str	r3, [r7, #28]
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
 8008cb0:	f107 0310 	add.w	r3, r7, #16
 8008cb4:	4619      	mov	r1, r3
 8008cb6:	480d      	ldr	r0, [pc, #52]	; (8008cec <HAL_CAN_MspInit+0xb4>)
 8008cb8:	f000 ff98 	bl	8009bec <HAL_GPIO_Init>

    /* CAN1 interrupt Init */
    HAL_NVIC_SetPriority(USB_LP_CAN1_RX0_IRQn, 0, 0);
 8008cbc:	2200      	movs	r2, #0
 8008cbe:	2100      	movs	r1, #0
 8008cc0:	2014      	movs	r0, #20
 8008cc2:	f000 ff5c 	bl	8009b7e <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(USB_LP_CAN1_RX0_IRQn);
 8008cc6:	2014      	movs	r0, #20
 8008cc8:	f000 ff75 	bl	8009bb6 <HAL_NVIC_EnableIRQ>
    HAL_NVIC_SetPriority(CAN1_RX1_IRQn, 0, 0);
 8008ccc:	2200      	movs	r2, #0
 8008cce:	2100      	movs	r1, #0
 8008cd0:	2015      	movs	r0, #21
 8008cd2:	f000 ff54 	bl	8009b7e <HAL_NVIC_SetPriority>
    HAL_NVIC_EnableIRQ(CAN1_RX1_IRQn);
 8008cd6:	2015      	movs	r0, #21
 8008cd8:	f000 ff6d 	bl	8009bb6 <HAL_NVIC_EnableIRQ>
  /* USER CODE BEGIN CAN1_MspInit 1 */

  /* USER CODE END CAN1_MspInit 1 */
  }

}
 8008cdc:	bf00      	nop
 8008cde:	3720      	adds	r7, #32
 8008ce0:	46bd      	mov	sp, r7
 8008ce2:	bd80      	pop	{r7, pc}
 8008ce4:	40006400 	.word	0x40006400
 8008ce8:	40021000 	.word	0x40021000
 8008cec:	40010800 	.word	0x40010800

08008cf0 <NMI_Handler>:
/******************************************************************************/
/**
  * @brief This function handles Non maskable interrupt.
  */
void NMI_Handler(void)
{
 8008cf0:	b480      	push	{r7}
 8008cf2:	af00      	add	r7, sp, #0

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 8008cf4:	bf00      	nop
 8008cf6:	46bd      	mov	sp, r7
 8008cf8:	bc80      	pop	{r7}
 8008cfa:	4770      	bx	lr

08008cfc <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8008cfc:	b480      	push	{r7}
 8008cfe:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN HardFault_IRQn 0 */

  /* USER CODE END HardFault_IRQn 0 */
  while (1)
 8008d00:	e7fe      	b.n	8008d00 <HardFault_Handler+0x4>

08008d02 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8008d02:	b480      	push	{r7}
 8008d04:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN MemoryManagement_IRQn 0 */

  /* USER CODE END MemoryManagement_IRQn 0 */
  while (1)
 8008d06:	e7fe      	b.n	8008d06 <MemManage_Handler+0x4>

08008d08 <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8008d08:	b480      	push	{r7}
 8008d0a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN BusFault_IRQn 0 */

  /* USER CODE END BusFault_IRQn 0 */
  while (1)
 8008d0c:	e7fe      	b.n	8008d0c <BusFault_Handler+0x4>

08008d0e <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8008d0e:	b480      	push	{r7}
 8008d10:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN UsageFault_IRQn 0 */

  /* USER CODE END UsageFault_IRQn 0 */
  while (1)
 8008d12:	e7fe      	b.n	8008d12 <UsageFault_Handler+0x4>

08008d14 <SVC_Handler>:

/**
  * @brief This function handles System service call via SWI instruction.
  */
void SVC_Handler(void)
{
 8008d14:	b480      	push	{r7}
 8008d16:	af00      	add	r7, sp, #0

  /* USER CODE END SVCall_IRQn 0 */
  /* USER CODE BEGIN SVCall_IRQn 1 */

  /* USER CODE END SVCall_IRQn 1 */
}
 8008d18:	bf00      	nop
 8008d1a:	46bd      	mov	sp, r7
 8008d1c:	bc80      	pop	{r7}
 8008d1e:	4770      	bx	lr

08008d20 <DebugMon_Handler>:

/**
  * @brief This function handles Debug monitor.
  */
void DebugMon_Handler(void)
{
 8008d20:	b480      	push	{r7}
 8008d22:	af00      	add	r7, sp, #0

  /* USER CODE END DebugMonitor_IRQn 0 */
  /* USER CODE BEGIN DebugMonitor_IRQn 1 */

  /* USER CODE END DebugMonitor_IRQn 1 */
}
 8008d24:	bf00      	nop
 8008d26:	46bd      	mov	sp, r7
 8008d28:	bc80      	pop	{r7}
 8008d2a:	4770      	bx	lr

08008d2c <PendSV_Handler>:

/**
  * @brief This function handles Pendable request for system service.
  */
void PendSV_Handler(void)
{
 8008d2c:	b480      	push	{r7}
 8008d2e:	af00      	add	r7, sp, #0

  /* USER CODE END PendSV_IRQn 0 */
  /* USER CODE BEGIN PendSV_IRQn 1 */

  /* USER CODE END PendSV_IRQn 1 */
}
 8008d30:	bf00      	nop
 8008d32:	46bd      	mov	sp, r7
 8008d34:	bc80      	pop	{r7}
 8008d36:	4770      	bx	lr

08008d38 <SysTick_Handler>:

/**
  * @brief This function handles System tick timer.
  */
void SysTick_Handler(void)
{
 8008d38:	b580      	push	{r7, lr}
 8008d3a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8008d3c:	f000 f8ae 	bl	8008e9c <HAL_IncTick>
  /* USER CODE BEGIN SysTick_IRQn 1 */

  /* USER CODE END SysTick_IRQn 1 */
}
 8008d40:	bf00      	nop
 8008d42:	bd80      	pop	{r7, pc}

08008d44 <USB_LP_CAN1_RX0_IRQHandler>:

/**
  * @brief This function handles USB low priority or CAN RX0 interrupts.
  */
void USB_LP_CAN1_RX0_IRQHandler(void)
{
 8008d44:	b580      	push	{r7, lr}
 8008d46:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN USB_LP_CAN1_RX0_IRQn 0 */

  /* USER CODE END USB_LP_CAN1_RX0_IRQn 0 */
  HAL_CAN_IRQHandler(&hcan);
 8008d48:	4802      	ldr	r0, [pc, #8]	; (8008d54 <USB_LP_CAN1_RX0_IRQHandler+0x10>)
 8008d4a:	f000 fc23 	bl	8009594 <HAL_CAN_IRQHandler>
  /* USER CODE BEGIN USB_LP_CAN1_RX0_IRQn 1 */

  /* USER CODE END USB_LP_CAN1_RX0_IRQn 1 */
}
 8008d4e:	bf00      	nop
 8008d50:	bd80      	pop	{r7, pc}
 8008d52:	bf00      	nop
 8008d54:	20000030 	.word	0x20000030

08008d58 <CAN1_RX1_IRQHandler>:

/**
  * @brief This function handles CAN RX1 interrupt.
  */
void CAN1_RX1_IRQHandler(void)
{
 8008d58:	b580      	push	{r7, lr}
 8008d5a:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN CAN1_RX1_IRQn 0 */

  /* USER CODE END CAN1_RX1_IRQn 0 */
  HAL_CAN_IRQHandler(&hcan);
 8008d5c:	4802      	ldr	r0, [pc, #8]	; (8008d68 <CAN1_RX1_IRQHandler+0x10>)
 8008d5e:	f000 fc19 	bl	8009594 <HAL_CAN_IRQHandler>
  /* USER CODE BEGIN CAN1_RX1_IRQn 1 */

  /* USER CODE END CAN1_RX1_IRQn 1 */
}
 8008d62:	bf00      	nop
 8008d64:	bd80      	pop	{r7, pc}
 8008d66:	bf00      	nop
 8008d68:	20000030 	.word	0x20000030

08008d6c <EXTI15_10_IRQHandler>:

/**
  * @brief This function handles EXTI line[15:10] interrupts.
  */
void EXTI15_10_IRQHandler(void)
{
 8008d6c:	b580      	push	{r7, lr}
 8008d6e:	af00      	add	r7, sp, #0
  /* USER CODE BEGIN EXTI15_10_IRQn 0 */

  /* USER CODE END EXTI15_10_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_11);
 8008d70:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8008d74:	f001 f8c6 	bl	8009f04 <HAL_GPIO_EXTI_IRQHandler>
  /* USER CODE BEGIN EXTI15_10_IRQn 1 */

  /* USER CODE END EXTI15_10_IRQn 1 */
}
 8008d78:	bf00      	nop
 8008d7a:	bd80      	pop	{r7, pc}

08008d7c <SystemInit>:
  * @note   This function should be used only after reset.
  * @param  None
  * @retval None
  */
void SystemInit (void)
{
 8008d7c:	b480      	push	{r7}
 8008d7e:	af00      	add	r7, sp, #0

  /* Configure the Vector Table location -------------------------------------*/
#if defined(USER_VECT_TAB_ADDRESS)
  SCB->VTOR = VECT_TAB_BASE_ADDRESS | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
#endif /* USER_VECT_TAB_ADDRESS */
}
 8008d80:	bf00      	nop
 8008d82:	46bd      	mov	sp, r7
 8008d84:	bc80      	pop	{r7}
 8008d86:	4770      	bx	lr

08008d88 <Reset_Handler>:
  .weak Reset_Handler
  .type Reset_Handler, %function
Reset_Handler:

/* Copy the data segment initializers from flash to SRAM */
  ldr r0, =_sdata
 8008d88:	480c      	ldr	r0, [pc, #48]	; (8008dbc <LoopFillZerobss+0x12>)
  ldr r1, =_edata
 8008d8a:	490d      	ldr	r1, [pc, #52]	; (8008dc0 <LoopFillZerobss+0x16>)
  ldr r2, =_sidata
 8008d8c:	4a0d      	ldr	r2, [pc, #52]	; (8008dc4 <LoopFillZerobss+0x1a>)
  movs r3, #0
 8008d8e:	2300      	movs	r3, #0
  b LoopCopyDataInit
 8008d90:	e002      	b.n	8008d98 <LoopCopyDataInit>

08008d92 <CopyDataInit>:

CopyDataInit:
  ldr r4, [r2, r3]
 8008d92:	58d4      	ldr	r4, [r2, r3]
  str r4, [r0, r3]
 8008d94:	50c4      	str	r4, [r0, r3]
  adds r3, r3, #4
 8008d96:	3304      	adds	r3, #4

08008d98 <LoopCopyDataInit>:

LoopCopyDataInit:
  adds r4, r0, r3
 8008d98:	18c4      	adds	r4, r0, r3
  cmp r4, r1
 8008d9a:	428c      	cmp	r4, r1
  bcc CopyDataInit
 8008d9c:	d3f9      	bcc.n	8008d92 <CopyDataInit>
  
/* Zero fill the bss segment. */
  ldr r2, =_sbss
 8008d9e:	4a0a      	ldr	r2, [pc, #40]	; (8008dc8 <LoopFillZerobss+0x1e>)
  ldr r4, =_ebss
 8008da0:	4c0a      	ldr	r4, [pc, #40]	; (8008dcc <LoopFillZerobss+0x22>)
  movs r3, #0
 8008da2:	2300      	movs	r3, #0
  b LoopFillZerobss
 8008da4:	e001      	b.n	8008daa <LoopFillZerobss>

08008da6 <FillZerobss>:

FillZerobss:
  str  r3, [r2]
 8008da6:	6013      	str	r3, [r2, #0]
  adds r2, r2, #4
 8008da8:	3204      	adds	r2, #4

08008daa <LoopFillZerobss>:

LoopFillZerobss:
  cmp r2, r4
 8008daa:	42a2      	cmp	r2, r4
  bcc FillZerobss
 8008dac:	d3fb      	bcc.n	8008da6 <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 8008dae:	f7ff ffe5 	bl	8008d7c <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 8008db2:	f001 f8bf 	bl	8009f34 <__libc_init_array>
/* Call the application's entry point.*/
  bl main
 8008db6:	f7ff fda7 	bl	8008908 <main>
  bx lr
 8008dba:	4770      	bx	lr
  ldr r0, =_sdata
 8008dbc:	20000000 	.word	0x20000000
  ldr r1, =_edata
 8008dc0:	2000000c 	.word	0x2000000c
  ldr r2, =_sidata
 8008dc4:	08009fcc 	.word	0x08009fcc
  ldr r2, =_sbss
 8008dc8:	2000000c 	.word	0x2000000c
  ldr r4, =_ebss
 8008dcc:	2000007c 	.word	0x2000007c

08008dd0 <ADC1_2_IRQHandler>:
 * @retval : None
*/
    .section .text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
  b Infinite_Loop
 8008dd0:	e7fe      	b.n	8008dd0 <ADC1_2_IRQHandler>
	...

08008dd4 <HAL_Init>:
  *         need to ensure that the SysTick time base is always set to 1 millisecond
  *         to have correct HAL operation.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_Init(void)
{
 8008dd4:	b580      	push	{r7, lr}
 8008dd6:	af00      	add	r7, sp, #0
    defined(STM32F102x6) || defined(STM32F102xB) || \
    defined(STM32F103x6) || defined(STM32F103xB) || defined(STM32F103xE) || defined(STM32F103xG) || \
    defined(STM32F105xC) || defined(STM32F107xC)

  /* Prefetch buffer is not available on value line devices */
  __HAL_FLASH_PREFETCH_BUFFER_ENABLE();
 8008dd8:	4b08      	ldr	r3, [pc, #32]	; (8008dfc <HAL_Init+0x28>)
 8008dda:	681b      	ldr	r3, [r3, #0]
 8008ddc:	4a07      	ldr	r2, [pc, #28]	; (8008dfc <HAL_Init+0x28>)
 8008dde:	f043 0310 	orr.w	r3, r3, #16
 8008de2:	6013      	str	r3, [r2, #0]
#endif
#endif /* PREFETCH_ENABLE */

  /* Set Interrupt Group Priority */
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 8008de4:	2003      	movs	r0, #3
 8008de6:	f000 febf 	bl	8009b68 <HAL_NVIC_SetPriorityGrouping>

  /* Use systick as time base source and configure 1ms tick (default clock after Reset is HSI) */
  HAL_InitTick(TICK_INT_PRIORITY);
 8008dea:	2000      	movs	r0, #0
 8008dec:	f000 f826 	bl	8008e3c <HAL_InitTick>

  /* Init the low level hardware */
  HAL_MspInit();
 8008df0:	f7ff fef0 	bl	8008bd4 <HAL_MspInit>

  /* Return function status */
  return HAL_OK;
 8008df4:	2300      	movs	r3, #0
}
 8008df6:	4618      	mov	r0, r3
 8008df8:	bd80      	pop	{r7, pc}
 8008dfa:	bf00      	nop
 8008dfc:	40022000 	.word	0x40022000

08008e00 <HAL_DeInit>:
  *        of time base.
  * @note This function is optional.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_DeInit(void)
{
 8008e00:	b580      	push	{r7, lr}
 8008e02:	af00      	add	r7, sp, #0
  /* Reset of all peripherals */
  __HAL_RCC_APB1_FORCE_RESET();
 8008e04:	4b09      	ldr	r3, [pc, #36]	; (8008e2c <HAL_DeInit+0x2c>)
 8008e06:	f04f 32ff 	mov.w	r2, #4294967295
 8008e0a:	60da      	str	r2, [r3, #12]
  __HAL_RCC_APB1_RELEASE_RESET();
 8008e0c:	4b07      	ldr	r3, [pc, #28]	; (8008e2c <HAL_DeInit+0x2c>)
 8008e0e:	2200      	movs	r2, #0
 8008e10:	611a      	str	r2, [r3, #16]

  __HAL_RCC_APB2_FORCE_RESET();
 8008e12:	4b06      	ldr	r3, [pc, #24]	; (8008e2c <HAL_DeInit+0x2c>)
 8008e14:	f04f 32ff 	mov.w	r2, #4294967295
 8008e18:	60da      	str	r2, [r3, #12]
  __HAL_RCC_APB2_RELEASE_RESET();
 8008e1a:	4b04      	ldr	r3, [pc, #16]	; (8008e2c <HAL_DeInit+0x2c>)
 8008e1c:	2200      	movs	r2, #0
 8008e1e:	60da      	str	r2, [r3, #12]
  __HAL_RCC_AHB_FORCE_RESET();
  __HAL_RCC_AHB_RELEASE_RESET();
#endif

  /* De-Init the low level hardware */
  HAL_MspDeInit();
 8008e20:	f000 f806 	bl	8008e30 <HAL_MspDeInit>

  /* Return function status */
  return HAL_OK;
 8008e24:	2300      	movs	r3, #0
}
 8008e26:	4618      	mov	r0, r3
 8008e28:	bd80      	pop	{r7, pc}
 8008e2a:	bf00      	nop
 8008e2c:	40021000 	.word	0x40021000

08008e30 <HAL_MspDeInit>:
/**
  * @brief  DeInitializes the MSP.
  * @retval None
  */
__weak void HAL_MspDeInit(void)
{
 8008e30:	b480      	push	{r7}
 8008e32:	af00      	add	r7, sp, #0
  /* NOTE : This function should not be modified, when the callback is needed,
            the HAL_MspDeInit could be implemented in the user file
   */
}
 8008e34:	bf00      	nop
 8008e36:	46bd      	mov	sp, r7
 8008e38:	bc80      	pop	{r7}
 8008e3a:	4770      	bx	lr

08008e3c <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8008e3c:	b580      	push	{r7, lr}
 8008e3e:	b082      	sub	sp, #8
 8008e40:	af00      	add	r7, sp, #0
 8008e42:	6078      	str	r0, [r7, #4]
  /* Configure the SysTick to have interrupt in 1ms time basis*/
  if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) > 0U)
 8008e44:	4b12      	ldr	r3, [pc, #72]	; (8008e90 <HAL_InitTick+0x54>)
 8008e46:	681a      	ldr	r2, [r3, #0]
 8008e48:	4b12      	ldr	r3, [pc, #72]	; (8008e94 <HAL_InitTick+0x58>)
 8008e4a:	781b      	ldrb	r3, [r3, #0]
 8008e4c:	4619      	mov	r1, r3
 8008e4e:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8008e52:	fbb3 f3f1 	udiv	r3, r3, r1
 8008e56:	fbb2 f3f3 	udiv	r3, r2, r3
 8008e5a:	4618      	mov	r0, r3
 8008e5c:	f000 feb9 	bl	8009bd2 <HAL_SYSTICK_Config>
 8008e60:	4603      	mov	r3, r0
 8008e62:	2b00      	cmp	r3, #0
 8008e64:	d001      	beq.n	8008e6a <HAL_InitTick+0x2e>
  {
    return HAL_ERROR;
 8008e66:	2301      	movs	r3, #1
 8008e68:	e00e      	b.n	8008e88 <HAL_InitTick+0x4c>
  }

  /* Configure the SysTick IRQ priority */
  if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 8008e6a:	687b      	ldr	r3, [r7, #4]
 8008e6c:	2b0f      	cmp	r3, #15
 8008e6e:	d80a      	bhi.n	8008e86 <HAL_InitTick+0x4a>
  {
    HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8008e70:	2200      	movs	r2, #0
 8008e72:	6879      	ldr	r1, [r7, #4]
 8008e74:	f04f 30ff 	mov.w	r0, #4294967295
 8008e78:	f000 fe81 	bl	8009b7e <HAL_NVIC_SetPriority>
    uwTickPrio = TickPriority;
 8008e7c:	4a06      	ldr	r2, [pc, #24]	; (8008e98 <HAL_InitTick+0x5c>)
 8008e7e:	687b      	ldr	r3, [r7, #4]
 8008e80:	6013      	str	r3, [r2, #0]
  {
    return HAL_ERROR;
  }

  /* Return function status */
  return HAL_OK;
 8008e82:	2300      	movs	r3, #0
 8008e84:	e000      	b.n	8008e88 <HAL_InitTick+0x4c>
    return HAL_ERROR;
 8008e86:	2301      	movs	r3, #1
}
 8008e88:	4618      	mov	r0, r3
 8008e8a:	3708      	adds	r7, #8
 8008e8c:	46bd      	mov	sp, r7
 8008e8e:	bd80      	pop	{r7, pc}
 8008e90:	20000000 	.word	0x20000000
 8008e94:	20000008 	.word	0x20000008
 8008e98:	20000004 	.word	0x20000004

08008e9c <HAL_IncTick>:
  * @note This function is declared as __weak to be overwritten in case of other
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
 8008e9c:	b480      	push	{r7}
 8008e9e:	af00      	add	r7, sp, #0
  uwTick += uwTickFreq;
 8008ea0:	4b05      	ldr	r3, [pc, #20]	; (8008eb8 <HAL_IncTick+0x1c>)
 8008ea2:	781b      	ldrb	r3, [r3, #0]
 8008ea4:	461a      	mov	r2, r3
 8008ea6:	4b05      	ldr	r3, [pc, #20]	; (8008ebc <HAL_IncTick+0x20>)
 8008ea8:	681b      	ldr	r3, [r3, #0]
 8008eaa:	4413      	add	r3, r2
 8008eac:	4a03      	ldr	r2, [pc, #12]	; (8008ebc <HAL_IncTick+0x20>)
 8008eae:	6013      	str	r3, [r2, #0]
}
 8008eb0:	bf00      	nop
 8008eb2:	46bd      	mov	sp, r7
 8008eb4:	bc80      	pop	{r7}
 8008eb6:	4770      	bx	lr
 8008eb8:	20000008 	.word	0x20000008
 8008ebc:	20000078 	.word	0x20000078

08008ec0 <HAL_GetTick>:
  * @note  This function is declared as __weak to be overwritten in case of other
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
 8008ec0:	b480      	push	{r7}
 8008ec2:	af00      	add	r7, sp, #0
  return uwTick;
 8008ec4:	4b02      	ldr	r3, [pc, #8]	; (8008ed0 <HAL_GetTick+0x10>)
 8008ec6:	681b      	ldr	r3, [r3, #0]
}
 8008ec8:	4618      	mov	r0, r3
 8008eca:	46bd      	mov	sp, r7
 8008ecc:	bc80      	pop	{r7}
 8008ece:	4770      	bx	lr
 8008ed0:	20000078 	.word	0x20000078

08008ed4 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 8008ed4:	b580      	push	{r7, lr}
 8008ed6:	b084      	sub	sp, #16
 8008ed8:	af00      	add	r7, sp, #0
 8008eda:	6078      	str	r0, [r7, #4]
  uint32_t tickstart = HAL_GetTick();
 8008edc:	f7ff fff0 	bl	8008ec0 <HAL_GetTick>
 8008ee0:	60b8      	str	r0, [r7, #8]
  uint32_t wait = Delay;
 8008ee2:	687b      	ldr	r3, [r7, #4]
 8008ee4:	60fb      	str	r3, [r7, #12]

  /* Add a freq to guarantee minimum wait */
  if (wait < HAL_MAX_DELAY)
 8008ee6:	68fb      	ldr	r3, [r7, #12]
 8008ee8:	f1b3 3fff 	cmp.w	r3, #4294967295
 8008eec:	d005      	beq.n	8008efa <HAL_Delay+0x26>
  {
    wait += (uint32_t)(uwTickFreq);
 8008eee:	4b09      	ldr	r3, [pc, #36]	; (8008f14 <HAL_Delay+0x40>)
 8008ef0:	781b      	ldrb	r3, [r3, #0]
 8008ef2:	461a      	mov	r2, r3
 8008ef4:	68fb      	ldr	r3, [r7, #12]
 8008ef6:	4413      	add	r3, r2
 8008ef8:	60fb      	str	r3, [r7, #12]
  }

  while ((HAL_GetTick() - tickstart) < wait)
 8008efa:	bf00      	nop
 8008efc:	f7ff ffe0 	bl	8008ec0 <HAL_GetTick>
 8008f00:	4602      	mov	r2, r0
 8008f02:	68bb      	ldr	r3, [r7, #8]
 8008f04:	1ad3      	subs	r3, r2, r3
 8008f06:	68fa      	ldr	r2, [r7, #12]
 8008f08:	429a      	cmp	r2, r3
 8008f0a:	d8f7      	bhi.n	8008efc <HAL_Delay+0x28>
  {
  }
}
 8008f0c:	bf00      	nop
 8008f0e:	3710      	adds	r7, #16
 8008f10:	46bd      	mov	sp, r7
 8008f12:	bd80      	pop	{r7, pc}
 8008f14:	20000008 	.word	0x20000008

08008f18 <HAL_CAN_Init>:
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_Init(CAN_HandleTypeDef *hcan)
{
 8008f18:	b580      	push	{r7, lr}
 8008f1a:	b084      	sub	sp, #16
 8008f1c:	af00      	add	r7, sp, #0
 8008f1e:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  /* Check CAN handle */
  if (hcan == NULL)
 8008f20:	687b      	ldr	r3, [r7, #4]
 8008f22:	2b00      	cmp	r3, #0
 8008f24:	d101      	bne.n	8008f2a <HAL_CAN_Init+0x12>
  {
    return HAL_ERROR;
 8008f26:	2301      	movs	r3, #1
 8008f28:	e0ed      	b.n	8009106 <HAL_CAN_Init+0x1ee>
    /* Init the low level hardware: CLOCK, NVIC */
    hcan->MspInitCallback(hcan);
  }

#else
  if (hcan->State == HAL_CAN_STATE_RESET)
 8008f2a:	687b      	ldr	r3, [r7, #4]
 8008f2c:	f893 3020 	ldrb.w	r3, [r3, #32]
 8008f30:	b2db      	uxtb	r3, r3
 8008f32:	2b00      	cmp	r3, #0
 8008f34:	d102      	bne.n	8008f3c <HAL_CAN_Init+0x24>
  {
    /* Init the low level hardware: CLOCK, NVIC */
    HAL_CAN_MspInit(hcan);
 8008f36:	6878      	ldr	r0, [r7, #4]
 8008f38:	f7ff fe7e 	bl	8008c38 <HAL_CAN_MspInit>
  }
#endif /* (USE_HAL_CAN_REGISTER_CALLBACKS) */

  /* Request initialisation */
  SET_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);
 8008f3c:	687b      	ldr	r3, [r7, #4]
 8008f3e:	681b      	ldr	r3, [r3, #0]
 8008f40:	681a      	ldr	r2, [r3, #0]
 8008f42:	687b      	ldr	r3, [r7, #4]
 8008f44:	681b      	ldr	r3, [r3, #0]
 8008f46:	f042 0201 	orr.w	r2, r2, #1
 8008f4a:	601a      	str	r2, [r3, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8008f4c:	f7ff ffb8 	bl	8008ec0 <HAL_GetTick>
 8008f50:	60f8      	str	r0, [r7, #12]

  /* Wait initialisation acknowledge */
  while ((hcan->Instance->MSR & CAN_MSR_INAK) == 0U)
 8008f52:	e012      	b.n	8008f7a <HAL_CAN_Init+0x62>
  {
    if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
 8008f54:	f7ff ffb4 	bl	8008ec0 <HAL_GetTick>
 8008f58:	4602      	mov	r2, r0
 8008f5a:	68fb      	ldr	r3, [r7, #12]
 8008f5c:	1ad3      	subs	r3, r2, r3
 8008f5e:	2b0a      	cmp	r3, #10
 8008f60:	d90b      	bls.n	8008f7a <HAL_CAN_Init+0x62>
    {
      /* Update error code */
      hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
 8008f62:	687b      	ldr	r3, [r7, #4]
 8008f64:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8008f66:	f443 3200 	orr.w	r2, r3, #131072	; 0x20000
 8008f6a:	687b      	ldr	r3, [r7, #4]
 8008f6c:	625a      	str	r2, [r3, #36]	; 0x24

      /* Change CAN state */
      hcan->State = HAL_CAN_STATE_ERROR;
 8008f6e:	687b      	ldr	r3, [r7, #4]
 8008f70:	2205      	movs	r2, #5
 8008f72:	f883 2020 	strb.w	r2, [r3, #32]

      return HAL_ERROR;
 8008f76:	2301      	movs	r3, #1
 8008f78:	e0c5      	b.n	8009106 <HAL_CAN_Init+0x1ee>
  while ((hcan->Instance->MSR & CAN_MSR_INAK) == 0U)
 8008f7a:	687b      	ldr	r3, [r7, #4]
 8008f7c:	681b      	ldr	r3, [r3, #0]
 8008f7e:	685b      	ldr	r3, [r3, #4]
 8008f80:	f003 0301 	and.w	r3, r3, #1
 8008f84:	2b00      	cmp	r3, #0
 8008f86:	d0e5      	beq.n	8008f54 <HAL_CAN_Init+0x3c>
    }
  }

  /* Exit from sleep mode */
  CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_SLEEP);
 8008f88:	687b      	ldr	r3, [r7, #4]
 8008f8a:	681b      	ldr	r3, [r3, #0]
 8008f8c:	681a      	ldr	r2, [r3, #0]
 8008f8e:	687b      	ldr	r3, [r7, #4]
 8008f90:	681b      	ldr	r3, [r3, #0]
 8008f92:	f022 0202 	bic.w	r2, r2, #2
 8008f96:	601a      	str	r2, [r3, #0]

  /* Get tick */
  tickstart = HAL_GetTick();
 8008f98:	f7ff ff92 	bl	8008ec0 <HAL_GetTick>
 8008f9c:	60f8      	str	r0, [r7, #12]

  /* Check Sleep mode leave acknowledge */
  while ((hcan->Instance->MSR & CAN_MSR_SLAK) != 0U)
 8008f9e:	e012      	b.n	8008fc6 <HAL_CAN_Init+0xae>
  {
    if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
 8008fa0:	f7ff ff8e 	bl	8008ec0 <HAL_GetTick>
 8008fa4:	4602      	mov	r2, r0
 8008fa6:	68fb      	ldr	r3, [r7, #12]
 8008fa8:	1ad3      	subs	r3, r2, r3
 8008faa:	2b0a      	cmp	r3, #10
 8008fac:	d90b      	bls.n	8008fc6 <HAL_CAN_Init+0xae>
    {
      /* Update error code */
      hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
 8008fae:	687b      	ldr	r3, [r7, #4]
 8008fb0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8008fb2:	f443 3200 	orr.w	r2, r3, #131072	; 0x20000
 8008fb6:	687b      	ldr	r3, [r7, #4]
 8008fb8:	625a      	str	r2, [r3, #36]	; 0x24

      /* Change CAN state */
      hcan->State = HAL_CAN_STATE_ERROR;
 8008fba:	687b      	ldr	r3, [r7, #4]
 8008fbc:	2205      	movs	r2, #5
 8008fbe:	f883 2020 	strb.w	r2, [r3, #32]

      return HAL_ERROR;
 8008fc2:	2301      	movs	r3, #1
 8008fc4:	e09f      	b.n	8009106 <HAL_CAN_Init+0x1ee>
  while ((hcan->Instance->MSR & CAN_MSR_SLAK) != 0U)
 8008fc6:	687b      	ldr	r3, [r7, #4]
 8008fc8:	681b      	ldr	r3, [r3, #0]
 8008fca:	685b      	ldr	r3, [r3, #4]
 8008fcc:	f003 0302 	and.w	r3, r3, #2
 8008fd0:	2b00      	cmp	r3, #0
 8008fd2:	d1e5      	bne.n	8008fa0 <HAL_CAN_Init+0x88>
    }
  }

  /* Set the time triggered communication mode */
  if (hcan->Init.TimeTriggeredMode == ENABLE)
 8008fd4:	687b      	ldr	r3, [r7, #4]
 8008fd6:	7e1b      	ldrb	r3, [r3, #24]
 8008fd8:	2b01      	cmp	r3, #1
 8008fda:	d108      	bne.n	8008fee <HAL_CAN_Init+0xd6>
  {
    SET_BIT(hcan->Instance->MCR, CAN_MCR_TTCM);
 8008fdc:	687b      	ldr	r3, [r7, #4]
 8008fde:	681b      	ldr	r3, [r3, #0]
 8008fe0:	681a      	ldr	r2, [r3, #0]
 8008fe2:	687b      	ldr	r3, [r7, #4]
 8008fe4:	681b      	ldr	r3, [r3, #0]
 8008fe6:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8008fea:	601a      	str	r2, [r3, #0]
 8008fec:	e007      	b.n	8008ffe <HAL_CAN_Init+0xe6>
  }
  else
  {
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_TTCM);
 8008fee:	687b      	ldr	r3, [r7, #4]
 8008ff0:	681b      	ldr	r3, [r3, #0]
 8008ff2:	681a      	ldr	r2, [r3, #0]
 8008ff4:	687b      	ldr	r3, [r7, #4]
 8008ff6:	681b      	ldr	r3, [r3, #0]
 8008ff8:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8008ffc:	601a      	str	r2, [r3, #0]
  }

  /* Set the automatic bus-off management */
  if (hcan->Init.AutoBusOff == ENABLE)
 8008ffe:	687b      	ldr	r3, [r7, #4]
 8009000:	7e5b      	ldrb	r3, [r3, #25]
 8009002:	2b01      	cmp	r3, #1
 8009004:	d108      	bne.n	8009018 <HAL_CAN_Init+0x100>
  {
    SET_BIT(hcan->Instance->MCR, CAN_MCR_ABOM);
 8009006:	687b      	ldr	r3, [r7, #4]
 8009008:	681b      	ldr	r3, [r3, #0]
 800900a:	681a      	ldr	r2, [r3, #0]
 800900c:	687b      	ldr	r3, [r7, #4]
 800900e:	681b      	ldr	r3, [r3, #0]
 8009010:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8009014:	601a      	str	r2, [r3, #0]
 8009016:	e007      	b.n	8009028 <HAL_CAN_Init+0x110>
  }
  else
  {
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_ABOM);
 8009018:	687b      	ldr	r3, [r7, #4]
 800901a:	681b      	ldr	r3, [r3, #0]
 800901c:	681a      	ldr	r2, [r3, #0]
 800901e:	687b      	ldr	r3, [r7, #4]
 8009020:	681b      	ldr	r3, [r3, #0]
 8009022:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8009026:	601a      	str	r2, [r3, #0]
  }

  /* Set the automatic wake-up mode */
  if (hcan->Init.AutoWakeUp == ENABLE)
 8009028:	687b      	ldr	r3, [r7, #4]
 800902a:	7e9b      	ldrb	r3, [r3, #26]
 800902c:	2b01      	cmp	r3, #1
 800902e:	d108      	bne.n	8009042 <HAL_CAN_Init+0x12a>
  {
    SET_BIT(hcan->Instance->MCR, CAN_MCR_AWUM);
 8009030:	687b      	ldr	r3, [r7, #4]
 8009032:	681b      	ldr	r3, [r3, #0]
 8009034:	681a      	ldr	r2, [r3, #0]
 8009036:	687b      	ldr	r3, [r7, #4]
 8009038:	681b      	ldr	r3, [r3, #0]
 800903a:	f042 0220 	orr.w	r2, r2, #32
 800903e:	601a      	str	r2, [r3, #0]
 8009040:	e007      	b.n	8009052 <HAL_CAN_Init+0x13a>
  }
  else
  {
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_AWUM);
 8009042:	687b      	ldr	r3, [r7, #4]
 8009044:	681b      	ldr	r3, [r3, #0]
 8009046:	681a      	ldr	r2, [r3, #0]
 8009048:	687b      	ldr	r3, [r7, #4]
 800904a:	681b      	ldr	r3, [r3, #0]
 800904c:	f022 0220 	bic.w	r2, r2, #32
 8009050:	601a      	str	r2, [r3, #0]
  }

  /* Set the automatic retransmission */
  if (hcan->Init.AutoRetransmission == ENABLE)
 8009052:	687b      	ldr	r3, [r7, #4]
 8009054:	7edb      	ldrb	r3, [r3, #27]
 8009056:	2b01      	cmp	r3, #1
 8009058:	d108      	bne.n	800906c <HAL_CAN_Init+0x154>
  {
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_NART);
 800905a:	687b      	ldr	r3, [r7, #4]
 800905c:	681b      	ldr	r3, [r3, #0]
 800905e:	681a      	ldr	r2, [r3, #0]
 8009060:	687b      	ldr	r3, [r7, #4]
 8009062:	681b      	ldr	r3, [r3, #0]
 8009064:	f022 0210 	bic.w	r2, r2, #16
 8009068:	601a      	str	r2, [r3, #0]
 800906a:	e007      	b.n	800907c <HAL_CAN_Init+0x164>
  }
  else
  {
    SET_BIT(hcan->Instance->MCR, CAN_MCR_NART);
 800906c:	687b      	ldr	r3, [r7, #4]
 800906e:	681b      	ldr	r3, [r3, #0]
 8009070:	681a      	ldr	r2, [r3, #0]
 8009072:	687b      	ldr	r3, [r7, #4]
 8009074:	681b      	ldr	r3, [r3, #0]
 8009076:	f042 0210 	orr.w	r2, r2, #16
 800907a:	601a      	str	r2, [r3, #0]
  }

  /* Set the receive FIFO locked mode */
  if (hcan->Init.ReceiveFifoLocked == ENABLE)
 800907c:	687b      	ldr	r3, [r7, #4]
 800907e:	7f1b      	ldrb	r3, [r3, #28]
 8009080:	2b01      	cmp	r3, #1
 8009082:	d108      	bne.n	8009096 <HAL_CAN_Init+0x17e>
  {
    SET_BIT(hcan->Instance->MCR, CAN_MCR_RFLM);
 8009084:	687b      	ldr	r3, [r7, #4]
 8009086:	681b      	ldr	r3, [r3, #0]
 8009088:	681a      	ldr	r2, [r3, #0]
 800908a:	687b      	ldr	r3, [r7, #4]
 800908c:	681b      	ldr	r3, [r3, #0]
 800908e:	f042 0208 	orr.w	r2, r2, #8
 8009092:	601a      	str	r2, [r3, #0]
 8009094:	e007      	b.n	80090a6 <HAL_CAN_Init+0x18e>
  }
  else
  {
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_RFLM);
 8009096:	687b      	ldr	r3, [r7, #4]
 8009098:	681b      	ldr	r3, [r3, #0]
 800909a:	681a      	ldr	r2, [r3, #0]
 800909c:	687b      	ldr	r3, [r7, #4]
 800909e:	681b      	ldr	r3, [r3, #0]
 80090a0:	f022 0208 	bic.w	r2, r2, #8
 80090a4:	601a      	str	r2, [r3, #0]
  }

  /* Set the transmit FIFO priority */
  if (hcan->Init.TransmitFifoPriority == ENABLE)
 80090a6:	687b      	ldr	r3, [r7, #4]
 80090a8:	7f5b      	ldrb	r3, [r3, #29]
 80090aa:	2b01      	cmp	r3, #1
 80090ac:	d108      	bne.n	80090c0 <HAL_CAN_Init+0x1a8>
  {
    SET_BIT(hcan->Instance->MCR, CAN_MCR_TXFP);
 80090ae:	687b      	ldr	r3, [r7, #4]
 80090b0:	681b      	ldr	r3, [r3, #0]
 80090b2:	681a      	ldr	r2, [r3, #0]
 80090b4:	687b      	ldr	r3, [r7, #4]
 80090b6:	681b      	ldr	r3, [r3, #0]
 80090b8:	f042 0204 	orr.w	r2, r2, #4
 80090bc:	601a      	str	r2, [r3, #0]
 80090be:	e007      	b.n	80090d0 <HAL_CAN_Init+0x1b8>
  }
  else
  {
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_TXFP);
 80090c0:	687b      	ldr	r3, [r7, #4]
 80090c2:	681b      	ldr	r3, [r3, #0]
 80090c4:	681a      	ldr	r2, [r3, #0]
 80090c6:	687b      	ldr	r3, [r7, #4]
 80090c8:	681b      	ldr	r3, [r3, #0]
 80090ca:	f022 0204 	bic.w	r2, r2, #4
 80090ce:	601a      	str	r2, [r3, #0]
  }

  /* Set the bit timing register */
  WRITE_REG(hcan->Instance->BTR, (uint32_t)(hcan->Init.Mode           |
 80090d0:	687b      	ldr	r3, [r7, #4]
 80090d2:	689a      	ldr	r2, [r3, #8]
 80090d4:	687b      	ldr	r3, [r7, #4]
 80090d6:	68db      	ldr	r3, [r3, #12]
 80090d8:	431a      	orrs	r2, r3
 80090da:	687b      	ldr	r3, [r7, #4]
 80090dc:	691b      	ldr	r3, [r3, #16]
 80090de:	431a      	orrs	r2, r3
 80090e0:	687b      	ldr	r3, [r7, #4]
 80090e2:	695b      	ldr	r3, [r3, #20]
 80090e4:	ea42 0103 	orr.w	r1, r2, r3
 80090e8:	687b      	ldr	r3, [r7, #4]
 80090ea:	685b      	ldr	r3, [r3, #4]
 80090ec:	1e5a      	subs	r2, r3, #1
 80090ee:	687b      	ldr	r3, [r7, #4]
 80090f0:	681b      	ldr	r3, [r3, #0]
 80090f2:	430a      	orrs	r2, r1
 80090f4:	61da      	str	r2, [r3, #28]
                                            hcan->Init.TimeSeg1       |
                                            hcan->Init.TimeSeg2       |
                                            (hcan->Init.Prescaler - 1U)));

  /* Initialize the error code */
  hcan->ErrorCode = HAL_CAN_ERROR_NONE;
 80090f6:	687b      	ldr	r3, [r7, #4]
 80090f8:	2200      	movs	r2, #0
 80090fa:	625a      	str	r2, [r3, #36]	; 0x24

  /* Initialize the CAN state */
  hcan->State = HAL_CAN_STATE_READY;
 80090fc:	687b      	ldr	r3, [r7, #4]
 80090fe:	2201      	movs	r2, #1
 8009100:	f883 2020 	strb.w	r2, [r3, #32]

  /* Return function status */
  return HAL_OK;
 8009104:	2300      	movs	r3, #0
}
 8009106:	4618      	mov	r0, r3
 8009108:	3710      	adds	r7, #16
 800910a:	46bd      	mov	sp, r7
 800910c:	bd80      	pop	{r7, pc}

0800910e <HAL_CAN_ConfigFilter>:
  * @param  sFilterConfig pointer to a CAN_FilterTypeDef structure that
  *         contains the filter configuration information.
  * @retval None
  */
HAL_StatusTypeDef HAL_CAN_ConfigFilter(CAN_HandleTypeDef *hcan, CAN_FilterTypeDef *sFilterConfig)
{
 800910e:	b480      	push	{r7}
 8009110:	b087      	sub	sp, #28
 8009112:	af00      	add	r7, sp, #0
 8009114:	6078      	str	r0, [r7, #4]
 8009116:	6039      	str	r1, [r7, #0]
  uint32_t filternbrbitpos;
  CAN_TypeDef *can_ip = hcan->Instance;
 8009118:	687b      	ldr	r3, [r7, #4]
 800911a:	681b      	ldr	r3, [r3, #0]
 800911c:	617b      	str	r3, [r7, #20]
  HAL_CAN_StateTypeDef state = hcan->State;
 800911e:	687b      	ldr	r3, [r7, #4]
 8009120:	f893 3020 	ldrb.w	r3, [r3, #32]
 8009124:	74fb      	strb	r3, [r7, #19]

  if ((state == HAL_CAN_STATE_READY) ||
 8009126:	7cfb      	ldrb	r3, [r7, #19]
 8009128:	2b01      	cmp	r3, #1
 800912a:	d003      	beq.n	8009134 <HAL_CAN_ConfigFilter+0x26>
 800912c:	7cfb      	ldrb	r3, [r7, #19]
 800912e:	2b02      	cmp	r3, #2
 8009130:	f040 80aa 	bne.w	8009288 <HAL_CAN_ConfigFilter+0x17a>
    /* Check the parameters */
    assert_param(IS_CAN_FILTER_BANK_SINGLE(sFilterConfig->FilterBank));
#endif

    /* Initialisation mode for the filter */
    SET_BIT(can_ip->FMR, CAN_FMR_FINIT);
 8009134:	697b      	ldr	r3, [r7, #20]
 8009136:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 800913a:	f043 0201 	orr.w	r2, r3, #1
 800913e:	697b      	ldr	r3, [r7, #20]
 8009140:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200
    CLEAR_BIT(can_ip->FMR, CAN_FMR_CAN2SB);
    SET_BIT(can_ip->FMR, sFilterConfig->SlaveStartFilterBank << CAN_FMR_CAN2SB_Pos);

#endif
    /* Convert filter number into bit position */
    filternbrbitpos = (uint32_t)1 << (sFilterConfig->FilterBank & 0x1FU);
 8009144:	683b      	ldr	r3, [r7, #0]
 8009146:	695b      	ldr	r3, [r3, #20]
 8009148:	f003 031f 	and.w	r3, r3, #31
 800914c:	2201      	movs	r2, #1
 800914e:	fa02 f303 	lsl.w	r3, r2, r3
 8009152:	60fb      	str	r3, [r7, #12]

    /* Filter Deactivation */
    CLEAR_BIT(can_ip->FA1R, filternbrbitpos);
 8009154:	697b      	ldr	r3, [r7, #20]
 8009156:	f8d3 221c 	ldr.w	r2, [r3, #540]	; 0x21c
 800915a:	68fb      	ldr	r3, [r7, #12]
 800915c:	43db      	mvns	r3, r3
 800915e:	401a      	ands	r2, r3
 8009160:	697b      	ldr	r3, [r7, #20]
 8009162:	f8c3 221c 	str.w	r2, [r3, #540]	; 0x21c

    /* Filter Scale */
    if (sFilterConfig->FilterScale == CAN_FILTERSCALE_16BIT)
 8009166:	683b      	ldr	r3, [r7, #0]
 8009168:	69db      	ldr	r3, [r3, #28]
 800916a:	2b00      	cmp	r3, #0
 800916c:	d123      	bne.n	80091b6 <HAL_CAN_ConfigFilter+0xa8>
    {
      /* 16-bit scale for the filter */
      CLEAR_BIT(can_ip->FS1R, filternbrbitpos);
 800916e:	697b      	ldr	r3, [r7, #20]
 8009170:	f8d3 220c 	ldr.w	r2, [r3, #524]	; 0x20c
 8009174:	68fb      	ldr	r3, [r7, #12]
 8009176:	43db      	mvns	r3, r3
 8009178:	401a      	ands	r2, r3
 800917a:	697b      	ldr	r3, [r7, #20]
 800917c:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c

      /* First 16-bit identifier and First 16-bit mask */
      /* Or First 16-bit identifier and Second 16-bit identifier */
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16U) |
 8009180:	683b      	ldr	r3, [r7, #0]
 8009182:	68db      	ldr	r3, [r3, #12]
 8009184:	0419      	lsls	r1, r3, #16
        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdLow);
 8009186:	683b      	ldr	r3, [r7, #0]
 8009188:	685b      	ldr	r3, [r3, #4]
 800918a:	b29b      	uxth	r3, r3
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
 800918c:	683a      	ldr	r2, [r7, #0]
 800918e:	6952      	ldr	r2, [r2, #20]
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow) << 16U) |
 8009190:	4319      	orrs	r1, r3
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
 8009192:	697b      	ldr	r3, [r7, #20]
 8009194:	3248      	adds	r2, #72	; 0x48
 8009196:	f843 1032 	str.w	r1, [r3, r2, lsl #3]

      /* Second 16-bit identifier and Second 16-bit mask */
      /* Or Third 16-bit identifier and Fourth 16-bit identifier */
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
 800919a:	683b      	ldr	r3, [r7, #0]
 800919c:	689b      	ldr	r3, [r3, #8]
 800919e:	0419      	lsls	r1, r3, #16
        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdHigh);
 80091a0:	683b      	ldr	r3, [r7, #0]
 80091a2:	681b      	ldr	r3, [r3, #0]
 80091a4:	b29a      	uxth	r2, r3
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
 80091a6:	683b      	ldr	r3, [r7, #0]
 80091a8:	695b      	ldr	r3, [r3, #20]
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
 80091aa:	430a      	orrs	r2, r1
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
 80091ac:	6979      	ldr	r1, [r7, #20]
 80091ae:	3348      	adds	r3, #72	; 0x48
 80091b0:	00db      	lsls	r3, r3, #3
 80091b2:	440b      	add	r3, r1
 80091b4:	605a      	str	r2, [r3, #4]
    }

    if (sFilterConfig->FilterScale == CAN_FILTERSCALE_32BIT)
 80091b6:	683b      	ldr	r3, [r7, #0]
 80091b8:	69db      	ldr	r3, [r3, #28]
 80091ba:	2b01      	cmp	r3, #1
 80091bc:	d122      	bne.n	8009204 <HAL_CAN_ConfigFilter+0xf6>
    {
      /* 32-bit scale for the filter */
      SET_BIT(can_ip->FS1R, filternbrbitpos);
 80091be:	697b      	ldr	r3, [r7, #20]
 80091c0:	f8d3 220c 	ldr.w	r2, [r3, #524]	; 0x20c
 80091c4:	68fb      	ldr	r3, [r7, #12]
 80091c6:	431a      	orrs	r2, r3
 80091c8:	697b      	ldr	r3, [r7, #20]
 80091ca:	f8c3 220c 	str.w	r2, [r3, #524]	; 0x20c

      /* 32-bit identifier or First 32-bit identifier */
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdHigh) << 16U) |
 80091ce:	683b      	ldr	r3, [r7, #0]
 80091d0:	681b      	ldr	r3, [r3, #0]
 80091d2:	0419      	lsls	r1, r3, #16
        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdLow);
 80091d4:	683b      	ldr	r3, [r7, #0]
 80091d6:	685b      	ldr	r3, [r3, #4]
 80091d8:	b29b      	uxth	r3, r3
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
 80091da:	683a      	ldr	r2, [r7, #0]
 80091dc:	6952      	ldr	r2, [r2, #20]
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterIdHigh) << 16U) |
 80091de:	4319      	orrs	r1, r3
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR1 =
 80091e0:	697b      	ldr	r3, [r7, #20]
 80091e2:	3248      	adds	r2, #72	; 0x48
 80091e4:	f843 1032 	str.w	r1, [r3, r2, lsl #3]

      /* 32-bit mask or Second 32-bit identifier */
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
 80091e8:	683b      	ldr	r3, [r7, #0]
 80091ea:	689b      	ldr	r3, [r3, #8]
 80091ec:	0419      	lsls	r1, r3, #16
        (0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdLow);
 80091ee:	683b      	ldr	r3, [r7, #0]
 80091f0:	68db      	ldr	r3, [r3, #12]
 80091f2:	b29a      	uxth	r2, r3
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
 80091f4:	683b      	ldr	r3, [r7, #0]
 80091f6:	695b      	ldr	r3, [r3, #20]
        ((0x0000FFFFU & (uint32_t)sFilterConfig->FilterMaskIdHigh) << 16U) |
 80091f8:	430a      	orrs	r2, r1
      can_ip->sFilterRegister[sFilterConfig->FilterBank].FR2 =
 80091fa:	6979      	ldr	r1, [r7, #20]
 80091fc:	3348      	adds	r3, #72	; 0x48
 80091fe:	00db      	lsls	r3, r3, #3
 8009200:	440b      	add	r3, r1
 8009202:	605a      	str	r2, [r3, #4]
    }

    /* Filter Mode */
    if (sFilterConfig->FilterMode == CAN_FILTERMODE_IDMASK)
 8009204:	683b      	ldr	r3, [r7, #0]
 8009206:	699b      	ldr	r3, [r3, #24]
 8009208:	2b00      	cmp	r3, #0
 800920a:	d109      	bne.n	8009220 <HAL_CAN_ConfigFilter+0x112>
    {
      /* Id/Mask mode for the filter*/
      CLEAR_BIT(can_ip->FM1R, filternbrbitpos);
 800920c:	697b      	ldr	r3, [r7, #20]
 800920e:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 8009212:	68fb      	ldr	r3, [r7, #12]
 8009214:	43db      	mvns	r3, r3
 8009216:	401a      	ands	r2, r3
 8009218:	697b      	ldr	r3, [r7, #20]
 800921a:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
 800921e:	e007      	b.n	8009230 <HAL_CAN_ConfigFilter+0x122>
    }
    else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
    {
      /* Identifier list mode for the filter*/
      SET_BIT(can_ip->FM1R, filternbrbitpos);
 8009220:	697b      	ldr	r3, [r7, #20]
 8009222:	f8d3 2204 	ldr.w	r2, [r3, #516]	; 0x204
 8009226:	68fb      	ldr	r3, [r7, #12]
 8009228:	431a      	orrs	r2, r3
 800922a:	697b      	ldr	r3, [r7, #20]
 800922c:	f8c3 2204 	str.w	r2, [r3, #516]	; 0x204
    }

    /* Filter FIFO assignment */
    if (sFilterConfig->FilterFIFOAssignment == CAN_FILTER_FIFO0)
 8009230:	683b      	ldr	r3, [r7, #0]
 8009232:	691b      	ldr	r3, [r3, #16]
 8009234:	2b00      	cmp	r3, #0
 8009236:	d109      	bne.n	800924c <HAL_CAN_ConfigFilter+0x13e>
    {
      /* FIFO 0 assignation for the filter */
      CLEAR_BIT(can_ip->FFA1R, filternbrbitpos);
 8009238:	697b      	ldr	r3, [r7, #20]
 800923a:	f8d3 2214 	ldr.w	r2, [r3, #532]	; 0x214
 800923e:	68fb      	ldr	r3, [r7, #12]
 8009240:	43db      	mvns	r3, r3
 8009242:	401a      	ands	r2, r3
 8009244:	697b      	ldr	r3, [r7, #20]
 8009246:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
 800924a:	e007      	b.n	800925c <HAL_CAN_ConfigFilter+0x14e>
    }
    else
    {
      /* FIFO 1 assignation for the filter */
      SET_BIT(can_ip->FFA1R, filternbrbitpos);
 800924c:	697b      	ldr	r3, [r7, #20]
 800924e:	f8d3 2214 	ldr.w	r2, [r3, #532]	; 0x214
 8009252:	68fb      	ldr	r3, [r7, #12]
 8009254:	431a      	orrs	r2, r3
 8009256:	697b      	ldr	r3, [r7, #20]
 8009258:	f8c3 2214 	str.w	r2, [r3, #532]	; 0x214
    }

    /* Filter activation */
    if (sFilterConfig->FilterActivation == CAN_FILTER_ENABLE)
 800925c:	683b      	ldr	r3, [r7, #0]
 800925e:	6a1b      	ldr	r3, [r3, #32]
 8009260:	2b01      	cmp	r3, #1
 8009262:	d107      	bne.n	8009274 <HAL_CAN_ConfigFilter+0x166>
    {
      SET_BIT(can_ip->FA1R, filternbrbitpos);
 8009264:	697b      	ldr	r3, [r7, #20]
 8009266:	f8d3 221c 	ldr.w	r2, [r3, #540]	; 0x21c
 800926a:	68fb      	ldr	r3, [r7, #12]
 800926c:	431a      	orrs	r2, r3
 800926e:	697b      	ldr	r3, [r7, #20]
 8009270:	f8c3 221c 	str.w	r2, [r3, #540]	; 0x21c
    }

    /* Leave the initialisation mode for the filter */
    CLEAR_BIT(can_ip->FMR, CAN_FMR_FINIT);
 8009274:	697b      	ldr	r3, [r7, #20]
 8009276:	f8d3 3200 	ldr.w	r3, [r3, #512]	; 0x200
 800927a:	f023 0201 	bic.w	r2, r3, #1
 800927e:	697b      	ldr	r3, [r7, #20]
 8009280:	f8c3 2200 	str.w	r2, [r3, #512]	; 0x200

    /* Return function status */
    return HAL_OK;
 8009284:	2300      	movs	r3, #0
 8009286:	e006      	b.n	8009296 <HAL_CAN_ConfigFilter+0x188>
  }
  else
  {
    /* Update error code */
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
 8009288:	687b      	ldr	r3, [r7, #4]
 800928a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800928c:	f443 2280 	orr.w	r2, r3, #262144	; 0x40000
 8009290:	687b      	ldr	r3, [r7, #4]
 8009292:	625a      	str	r2, [r3, #36]	; 0x24

    return HAL_ERROR;
 8009294:	2301      	movs	r3, #1
  }
}
 8009296:	4618      	mov	r0, r3
 8009298:	371c      	adds	r7, #28
 800929a:	46bd      	mov	sp, r7
 800929c:	bc80      	pop	{r7}
 800929e:	4770      	bx	lr

080092a0 <HAL_CAN_Start>:
  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_Start(CAN_HandleTypeDef *hcan)
{
 80092a0:	b580      	push	{r7, lr}
 80092a2:	b084      	sub	sp, #16
 80092a4:	af00      	add	r7, sp, #0
 80092a6:	6078      	str	r0, [r7, #4]
  uint32_t tickstart;

  if (hcan->State == HAL_CAN_STATE_READY)
 80092a8:	687b      	ldr	r3, [r7, #4]
 80092aa:	f893 3020 	ldrb.w	r3, [r3, #32]
 80092ae:	b2db      	uxtb	r3, r3
 80092b0:	2b01      	cmp	r3, #1
 80092b2:	d12e      	bne.n	8009312 <HAL_CAN_Start+0x72>
  {
    /* Change CAN peripheral state */
    hcan->State = HAL_CAN_STATE_LISTENING;
 80092b4:	687b      	ldr	r3, [r7, #4]
 80092b6:	2202      	movs	r2, #2
 80092b8:	f883 2020 	strb.w	r2, [r3, #32]

    /* Request leave initialisation */
    CLEAR_BIT(hcan->Instance->MCR, CAN_MCR_INRQ);
 80092bc:	687b      	ldr	r3, [r7, #4]
 80092be:	681b      	ldr	r3, [r3, #0]
 80092c0:	681a      	ldr	r2, [r3, #0]
 80092c2:	687b      	ldr	r3, [r7, #4]
 80092c4:	681b      	ldr	r3, [r3, #0]
 80092c6:	f022 0201 	bic.w	r2, r2, #1
 80092ca:	601a      	str	r2, [r3, #0]

    /* Get tick */
    tickstart = HAL_GetTick();
 80092cc:	f7ff fdf8 	bl	8008ec0 <HAL_GetTick>
 80092d0:	60f8      	str	r0, [r7, #12]

    /* Wait the acknowledge */
    while ((hcan->Instance->MSR & CAN_MSR_INAK) != 0U)
 80092d2:	e012      	b.n	80092fa <HAL_CAN_Start+0x5a>
    {
      /* Check for the Timeout */
      if ((HAL_GetTick() - tickstart) > CAN_TIMEOUT_VALUE)
 80092d4:	f7ff fdf4 	bl	8008ec0 <HAL_GetTick>
 80092d8:	4602      	mov	r2, r0
 80092da:	68fb      	ldr	r3, [r7, #12]
 80092dc:	1ad3      	subs	r3, r2, r3
 80092de:	2b0a      	cmp	r3, #10
 80092e0:	d90b      	bls.n	80092fa <HAL_CAN_Start+0x5a>
      {
        /* Update error code */
        hcan->ErrorCode |= HAL_CAN_ERROR_TIMEOUT;
 80092e2:	687b      	ldr	r3, [r7, #4]
 80092e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80092e6:	f443 3200 	orr.w	r2, r3, #131072	; 0x20000
 80092ea:	687b      	ldr	r3, [r7, #4]
 80092ec:	625a      	str	r2, [r3, #36]	; 0x24

        /* Change CAN state */
        hcan->State = HAL_CAN_STATE_ERROR;
 80092ee:	687b      	ldr	r3, [r7, #4]
 80092f0:	2205      	movs	r2, #5
 80092f2:	f883 2020 	strb.w	r2, [r3, #32]

        return HAL_ERROR;
 80092f6:	2301      	movs	r3, #1
 80092f8:	e012      	b.n	8009320 <HAL_CAN_Start+0x80>
    while ((hcan->Instance->MSR & CAN_MSR_INAK) != 0U)
 80092fa:	687b      	ldr	r3, [r7, #4]
 80092fc:	681b      	ldr	r3, [r3, #0]
 80092fe:	685b      	ldr	r3, [r3, #4]
 8009300:	f003 0301 	and.w	r3, r3, #1
 8009304:	2b00      	cmp	r3, #0
 8009306:	d1e5      	bne.n	80092d4 <HAL_CAN_Start+0x34>
      }
    }

    /* Reset the CAN ErrorCode */
    hcan->ErrorCode = HAL_CAN_ERROR_NONE;
 8009308:	687b      	ldr	r3, [r7, #4]
 800930a:	2200      	movs	r2, #0
 800930c:	625a      	str	r2, [r3, #36]	; 0x24

    /* Return function status */
    return HAL_OK;
 800930e:	2300      	movs	r3, #0
 8009310:	e006      	b.n	8009320 <HAL_CAN_Start+0x80>
  }
  else
  {
    /* Update error code */
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_READY;
 8009312:	687b      	ldr	r3, [r7, #4]
 8009314:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009316:	f443 2200 	orr.w	r2, r3, #524288	; 0x80000
 800931a:	687b      	ldr	r3, [r7, #4]
 800931c:	625a      	str	r2, [r3, #36]	; 0x24

    return HAL_ERROR;
 800931e:	2301      	movs	r3, #1
  }
}
 8009320:	4618      	mov	r0, r3
 8009322:	3710      	adds	r7, #16
 8009324:	46bd      	mov	sp, r7
 8009326:	bd80      	pop	{r7, pc}

08009328 <HAL_CAN_GetRxMessage>:
  *         of the Rx frame will be stored.
  * @param  aData array where the payload of the Rx frame will be stored.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_GetRxMessage(CAN_HandleTypeDef *hcan, uint32_t RxFifo, CAN_RxHeaderTypeDef *pHeader, uint8_t aData[])
{
 8009328:	b480      	push	{r7}
 800932a:	b087      	sub	sp, #28
 800932c:	af00      	add	r7, sp, #0
 800932e:	60f8      	str	r0, [r7, #12]
 8009330:	60b9      	str	r1, [r7, #8]
 8009332:	607a      	str	r2, [r7, #4]
 8009334:	603b      	str	r3, [r7, #0]
  HAL_CAN_StateTypeDef state = hcan->State;
 8009336:	68fb      	ldr	r3, [r7, #12]
 8009338:	f893 3020 	ldrb.w	r3, [r3, #32]
 800933c:	75fb      	strb	r3, [r7, #23]

  assert_param(IS_CAN_RX_FIFO(RxFifo));

  if ((state == HAL_CAN_STATE_READY) ||
 800933e:	7dfb      	ldrb	r3, [r7, #23]
 8009340:	2b01      	cmp	r3, #1
 8009342:	d003      	beq.n	800934c <HAL_CAN_GetRxMessage+0x24>
 8009344:	7dfb      	ldrb	r3, [r7, #23]
 8009346:	2b02      	cmp	r3, #2
 8009348:	f040 80f3 	bne.w	8009532 <HAL_CAN_GetRxMessage+0x20a>
      (state == HAL_CAN_STATE_LISTENING))
  {
    /* Check the Rx FIFO */
    if (RxFifo == CAN_RX_FIFO0) /* Rx element is assigned to Rx FIFO 0 */
 800934c:	68bb      	ldr	r3, [r7, #8]
 800934e:	2b00      	cmp	r3, #0
 8009350:	d10e      	bne.n	8009370 <HAL_CAN_GetRxMessage+0x48>
    {
      /* Check that the Rx FIFO 0 is not empty */
      if ((hcan->Instance->RF0R & CAN_RF0R_FMP0) == 0U)
 8009352:	68fb      	ldr	r3, [r7, #12]
 8009354:	681b      	ldr	r3, [r3, #0]
 8009356:	68db      	ldr	r3, [r3, #12]
 8009358:	f003 0303 	and.w	r3, r3, #3
 800935c:	2b00      	cmp	r3, #0
 800935e:	d116      	bne.n	800938e <HAL_CAN_GetRxMessage+0x66>
      {
        /* Update error code */
        hcan->ErrorCode |= HAL_CAN_ERROR_PARAM;
 8009360:	68fb      	ldr	r3, [r7, #12]
 8009362:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009364:	f443 1200 	orr.w	r2, r3, #2097152	; 0x200000
 8009368:	68fb      	ldr	r3, [r7, #12]
 800936a:	625a      	str	r2, [r3, #36]	; 0x24

        return HAL_ERROR;
 800936c:	2301      	movs	r3, #1
 800936e:	e0e7      	b.n	8009540 <HAL_CAN_GetRxMessage+0x218>
      }
    }
    else /* Rx element is assigned to Rx FIFO 1 */
    {
      /* Check that the Rx FIFO 1 is not empty */
      if ((hcan->Instance->RF1R & CAN_RF1R_FMP1) == 0U)
 8009370:	68fb      	ldr	r3, [r7, #12]
 8009372:	681b      	ldr	r3, [r3, #0]
 8009374:	691b      	ldr	r3, [r3, #16]
 8009376:	f003 0303 	and.w	r3, r3, #3
 800937a:	2b00      	cmp	r3, #0
 800937c:	d107      	bne.n	800938e <HAL_CAN_GetRxMessage+0x66>
      {
        /* Update error code */
        hcan->ErrorCode |= HAL_CAN_ERROR_PARAM;
 800937e:	68fb      	ldr	r3, [r7, #12]
 8009380:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009382:	f443 1200 	orr.w	r2, r3, #2097152	; 0x200000
 8009386:	68fb      	ldr	r3, [r7, #12]
 8009388:	625a      	str	r2, [r3, #36]	; 0x24

        return HAL_ERROR;
 800938a:	2301      	movs	r3, #1
 800938c:	e0d8      	b.n	8009540 <HAL_CAN_GetRxMessage+0x218>
      }
    }

    /* Get the header */
    pHeader->IDE = CAN_RI0R_IDE & hcan->Instance->sFIFOMailBox[RxFifo].RIR;
 800938e:	68fb      	ldr	r3, [r7, #12]
 8009390:	681a      	ldr	r2, [r3, #0]
 8009392:	68bb      	ldr	r3, [r7, #8]
 8009394:	331b      	adds	r3, #27
 8009396:	011b      	lsls	r3, r3, #4
 8009398:	4413      	add	r3, r2
 800939a:	681b      	ldr	r3, [r3, #0]
 800939c:	f003 0204 	and.w	r2, r3, #4
 80093a0:	687b      	ldr	r3, [r7, #4]
 80093a2:	609a      	str	r2, [r3, #8]
    if (pHeader->IDE == CAN_ID_STD)
 80093a4:	687b      	ldr	r3, [r7, #4]
 80093a6:	689b      	ldr	r3, [r3, #8]
 80093a8:	2b00      	cmp	r3, #0
 80093aa:	d10c      	bne.n	80093c6 <HAL_CAN_GetRxMessage+0x9e>
    {
      pHeader->StdId = (CAN_RI0R_STID & hcan->Instance->sFIFOMailBox[RxFifo].RIR) >> CAN_TI0R_STID_Pos;
 80093ac:	68fb      	ldr	r3, [r7, #12]
 80093ae:	681a      	ldr	r2, [r3, #0]
 80093b0:	68bb      	ldr	r3, [r7, #8]
 80093b2:	331b      	adds	r3, #27
 80093b4:	011b      	lsls	r3, r3, #4
 80093b6:	4413      	add	r3, r2
 80093b8:	681b      	ldr	r3, [r3, #0]
 80093ba:	0d5b      	lsrs	r3, r3, #21
 80093bc:	f3c3 020a 	ubfx	r2, r3, #0, #11
 80093c0:	687b      	ldr	r3, [r7, #4]
 80093c2:	601a      	str	r2, [r3, #0]
 80093c4:	e00b      	b.n	80093de <HAL_CAN_GetRxMessage+0xb6>
    }
    else
    {
      pHeader->ExtId = ((CAN_RI0R_EXID | CAN_RI0R_STID) & hcan->Instance->sFIFOMailBox[RxFifo].RIR) >> CAN_RI0R_EXID_Pos;
 80093c6:	68fb      	ldr	r3, [r7, #12]
 80093c8:	681a      	ldr	r2, [r3, #0]
 80093ca:	68bb      	ldr	r3, [r7, #8]
 80093cc:	331b      	adds	r3, #27
 80093ce:	011b      	lsls	r3, r3, #4
 80093d0:	4413      	add	r3, r2
 80093d2:	681b      	ldr	r3, [r3, #0]
 80093d4:	08db      	lsrs	r3, r3, #3
 80093d6:	f023 4260 	bic.w	r2, r3, #3758096384	; 0xe0000000
 80093da:	687b      	ldr	r3, [r7, #4]
 80093dc:	605a      	str	r2, [r3, #4]
    }
    pHeader->RTR = (CAN_RI0R_RTR & hcan->Instance->sFIFOMailBox[RxFifo].RIR);
 80093de:	68fb      	ldr	r3, [r7, #12]
 80093e0:	681a      	ldr	r2, [r3, #0]
 80093e2:	68bb      	ldr	r3, [r7, #8]
 80093e4:	331b      	adds	r3, #27
 80093e6:	011b      	lsls	r3, r3, #4
 80093e8:	4413      	add	r3, r2
 80093ea:	681b      	ldr	r3, [r3, #0]
 80093ec:	f003 0202 	and.w	r2, r3, #2
 80093f0:	687b      	ldr	r3, [r7, #4]
 80093f2:	60da      	str	r2, [r3, #12]
    pHeader->DLC = (CAN_RDT0R_DLC & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_DLC_Pos;
 80093f4:	68fb      	ldr	r3, [r7, #12]
 80093f6:	681a      	ldr	r2, [r3, #0]
 80093f8:	68bb      	ldr	r3, [r7, #8]
 80093fa:	331b      	adds	r3, #27
 80093fc:	011b      	lsls	r3, r3, #4
 80093fe:	4413      	add	r3, r2
 8009400:	3304      	adds	r3, #4
 8009402:	681b      	ldr	r3, [r3, #0]
 8009404:	f003 020f 	and.w	r2, r3, #15
 8009408:	687b      	ldr	r3, [r7, #4]
 800940a:	611a      	str	r2, [r3, #16]
    pHeader->FilterMatchIndex = (CAN_RDT0R_FMI & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_FMI_Pos;
 800940c:	68fb      	ldr	r3, [r7, #12]
 800940e:	681a      	ldr	r2, [r3, #0]
 8009410:	68bb      	ldr	r3, [r7, #8]
 8009412:	331b      	adds	r3, #27
 8009414:	011b      	lsls	r3, r3, #4
 8009416:	4413      	add	r3, r2
 8009418:	3304      	adds	r3, #4
 800941a:	681b      	ldr	r3, [r3, #0]
 800941c:	0a1b      	lsrs	r3, r3, #8
 800941e:	b2da      	uxtb	r2, r3
 8009420:	687b      	ldr	r3, [r7, #4]
 8009422:	619a      	str	r2, [r3, #24]
    pHeader->Timestamp = (CAN_RDT0R_TIME & hcan->Instance->sFIFOMailBox[RxFifo].RDTR) >> CAN_RDT0R_TIME_Pos;
 8009424:	68fb      	ldr	r3, [r7, #12]
 8009426:	681a      	ldr	r2, [r3, #0]
 8009428:	68bb      	ldr	r3, [r7, #8]
 800942a:	331b      	adds	r3, #27
 800942c:	011b      	lsls	r3, r3, #4
 800942e:	4413      	add	r3, r2
 8009430:	3304      	adds	r3, #4
 8009432:	681b      	ldr	r3, [r3, #0]
 8009434:	0c1b      	lsrs	r3, r3, #16
 8009436:	b29a      	uxth	r2, r3
 8009438:	687b      	ldr	r3, [r7, #4]
 800943a:	615a      	str	r2, [r3, #20]

    /* Get the data */
    aData[0] = (uint8_t)((CAN_RDL0R_DATA0 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA0_Pos);
 800943c:	68fb      	ldr	r3, [r7, #12]
 800943e:	681a      	ldr	r2, [r3, #0]
 8009440:	68bb      	ldr	r3, [r7, #8]
 8009442:	011b      	lsls	r3, r3, #4
 8009444:	4413      	add	r3, r2
 8009446:	f503 73dc 	add.w	r3, r3, #440	; 0x1b8
 800944a:	681b      	ldr	r3, [r3, #0]
 800944c:	b2da      	uxtb	r2, r3
 800944e:	683b      	ldr	r3, [r7, #0]
 8009450:	701a      	strb	r2, [r3, #0]
    aData[1] = (uint8_t)((CAN_RDL0R_DATA1 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA1_Pos);
 8009452:	68fb      	ldr	r3, [r7, #12]
 8009454:	681a      	ldr	r2, [r3, #0]
 8009456:	68bb      	ldr	r3, [r7, #8]
 8009458:	011b      	lsls	r3, r3, #4
 800945a:	4413      	add	r3, r2
 800945c:	f503 73dc 	add.w	r3, r3, #440	; 0x1b8
 8009460:	681b      	ldr	r3, [r3, #0]
 8009462:	0a1a      	lsrs	r2, r3, #8
 8009464:	683b      	ldr	r3, [r7, #0]
 8009466:	3301      	adds	r3, #1
 8009468:	b2d2      	uxtb	r2, r2
 800946a:	701a      	strb	r2, [r3, #0]
    aData[2] = (uint8_t)((CAN_RDL0R_DATA2 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA2_Pos);
 800946c:	68fb      	ldr	r3, [r7, #12]
 800946e:	681a      	ldr	r2, [r3, #0]
 8009470:	68bb      	ldr	r3, [r7, #8]
 8009472:	011b      	lsls	r3, r3, #4
 8009474:	4413      	add	r3, r2
 8009476:	f503 73dc 	add.w	r3, r3, #440	; 0x1b8
 800947a:	681b      	ldr	r3, [r3, #0]
 800947c:	0c1a      	lsrs	r2, r3, #16
 800947e:	683b      	ldr	r3, [r7, #0]
 8009480:	3302      	adds	r3, #2
 8009482:	b2d2      	uxtb	r2, r2
 8009484:	701a      	strb	r2, [r3, #0]
    aData[3] = (uint8_t)((CAN_RDL0R_DATA3 & hcan->Instance->sFIFOMailBox[RxFifo].RDLR) >> CAN_RDL0R_DATA3_Pos);
 8009486:	68fb      	ldr	r3, [r7, #12]
 8009488:	681a      	ldr	r2, [r3, #0]
 800948a:	68bb      	ldr	r3, [r7, #8]
 800948c:	011b      	lsls	r3, r3, #4
 800948e:	4413      	add	r3, r2
 8009490:	f503 73dc 	add.w	r3, r3, #440	; 0x1b8
 8009494:	681b      	ldr	r3, [r3, #0]
 8009496:	0e1a      	lsrs	r2, r3, #24
 8009498:	683b      	ldr	r3, [r7, #0]
 800949a:	3303      	adds	r3, #3
 800949c:	b2d2      	uxtb	r2, r2
 800949e:	701a      	strb	r2, [r3, #0]
    aData[4] = (uint8_t)((CAN_RDH0R_DATA4 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA4_Pos);
 80094a0:	68fb      	ldr	r3, [r7, #12]
 80094a2:	681a      	ldr	r2, [r3, #0]
 80094a4:	68bb      	ldr	r3, [r7, #8]
 80094a6:	011b      	lsls	r3, r3, #4
 80094a8:	4413      	add	r3, r2
 80094aa:	f503 73de 	add.w	r3, r3, #444	; 0x1bc
 80094ae:	681a      	ldr	r2, [r3, #0]
 80094b0:	683b      	ldr	r3, [r7, #0]
 80094b2:	3304      	adds	r3, #4
 80094b4:	b2d2      	uxtb	r2, r2
 80094b6:	701a      	strb	r2, [r3, #0]
    aData[5] = (uint8_t)((CAN_RDH0R_DATA5 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA5_Pos);
 80094b8:	68fb      	ldr	r3, [r7, #12]
 80094ba:	681a      	ldr	r2, [r3, #0]
 80094bc:	68bb      	ldr	r3, [r7, #8]
 80094be:	011b      	lsls	r3, r3, #4
 80094c0:	4413      	add	r3, r2
 80094c2:	f503 73de 	add.w	r3, r3, #444	; 0x1bc
 80094c6:	681b      	ldr	r3, [r3, #0]
 80094c8:	0a1a      	lsrs	r2, r3, #8
 80094ca:	683b      	ldr	r3, [r7, #0]
 80094cc:	3305      	adds	r3, #5
 80094ce:	b2d2      	uxtb	r2, r2
 80094d0:	701a      	strb	r2, [r3, #0]
    aData[6] = (uint8_t)((CAN_RDH0R_DATA6 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA6_Pos);
 80094d2:	68fb      	ldr	r3, [r7, #12]
 80094d4:	681a      	ldr	r2, [r3, #0]
 80094d6:	68bb      	ldr	r3, [r7, #8]
 80094d8:	011b      	lsls	r3, r3, #4
 80094da:	4413      	add	r3, r2
 80094dc:	f503 73de 	add.w	r3, r3, #444	; 0x1bc
 80094e0:	681b      	ldr	r3, [r3, #0]
 80094e2:	0c1a      	lsrs	r2, r3, #16
 80094e4:	683b      	ldr	r3, [r7, #0]
 80094e6:	3306      	adds	r3, #6
 80094e8:	b2d2      	uxtb	r2, r2
 80094ea:	701a      	strb	r2, [r3, #0]
    aData[7] = (uint8_t)((CAN_RDH0R_DATA7 & hcan->Instance->sFIFOMailBox[RxFifo].RDHR) >> CAN_RDH0R_DATA7_Pos);
 80094ec:	68fb      	ldr	r3, [r7, #12]
 80094ee:	681a      	ldr	r2, [r3, #0]
 80094f0:	68bb      	ldr	r3, [r7, #8]
 80094f2:	011b      	lsls	r3, r3, #4
 80094f4:	4413      	add	r3, r2
 80094f6:	f503 73de 	add.w	r3, r3, #444	; 0x1bc
 80094fa:	681b      	ldr	r3, [r3, #0]
 80094fc:	0e1a      	lsrs	r2, r3, #24
 80094fe:	683b      	ldr	r3, [r7, #0]
 8009500:	3307      	adds	r3, #7
 8009502:	b2d2      	uxtb	r2, r2
 8009504:	701a      	strb	r2, [r3, #0]

    /* Release the FIFO */
    if (RxFifo == CAN_RX_FIFO0) /* Rx element is assigned to Rx FIFO 0 */
 8009506:	68bb      	ldr	r3, [r7, #8]
 8009508:	2b00      	cmp	r3, #0
 800950a:	d108      	bne.n	800951e <HAL_CAN_GetRxMessage+0x1f6>
    {
      /* Release RX FIFO 0 */
      SET_BIT(hcan->Instance->RF0R, CAN_RF0R_RFOM0);
 800950c:	68fb      	ldr	r3, [r7, #12]
 800950e:	681b      	ldr	r3, [r3, #0]
 8009510:	68da      	ldr	r2, [r3, #12]
 8009512:	68fb      	ldr	r3, [r7, #12]
 8009514:	681b      	ldr	r3, [r3, #0]
 8009516:	f042 0220 	orr.w	r2, r2, #32
 800951a:	60da      	str	r2, [r3, #12]
 800951c:	e007      	b.n	800952e <HAL_CAN_GetRxMessage+0x206>
    }
    else /* Rx element is assigned to Rx FIFO 1 */
    {
      /* Release RX FIFO 1 */
      SET_BIT(hcan->Instance->RF1R, CAN_RF1R_RFOM1);
 800951e:	68fb      	ldr	r3, [r7, #12]
 8009520:	681b      	ldr	r3, [r3, #0]
 8009522:	691a      	ldr	r2, [r3, #16]
 8009524:	68fb      	ldr	r3, [r7, #12]
 8009526:	681b      	ldr	r3, [r3, #0]
 8009528:	f042 0220 	orr.w	r2, r2, #32
 800952c:	611a      	str	r2, [r3, #16]
    }

    /* Return function status */
    return HAL_OK;
 800952e:	2300      	movs	r3, #0
 8009530:	e006      	b.n	8009540 <HAL_CAN_GetRxMessage+0x218>
  }
  else
  {
    /* Update error code */
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
 8009532:	68fb      	ldr	r3, [r7, #12]
 8009534:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009536:	f443 2280 	orr.w	r2, r3, #262144	; 0x40000
 800953a:	68fb      	ldr	r3, [r7, #12]
 800953c:	625a      	str	r2, [r3, #36]	; 0x24

    return HAL_ERROR;
 800953e:	2301      	movs	r3, #1
  }
}
 8009540:	4618      	mov	r0, r3
 8009542:	371c      	adds	r7, #28
 8009544:	46bd      	mov	sp, r7
 8009546:	bc80      	pop	{r7}
 8009548:	4770      	bx	lr

0800954a <HAL_CAN_ActivateNotification>:
  * @param  ActiveITs indicates which interrupts will be enabled.
  *         This parameter can be any combination of @arg CAN_Interrupts.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_CAN_ActivateNotification(CAN_HandleTypeDef *hcan, uint32_t ActiveITs)
{
 800954a:	b480      	push	{r7}
 800954c:	b085      	sub	sp, #20
 800954e:	af00      	add	r7, sp, #0
 8009550:	6078      	str	r0, [r7, #4]
 8009552:	6039      	str	r1, [r7, #0]
  HAL_CAN_StateTypeDef state = hcan->State;
 8009554:	687b      	ldr	r3, [r7, #4]
 8009556:	f893 3020 	ldrb.w	r3, [r3, #32]
 800955a:	73fb      	strb	r3, [r7, #15]

  /* Check function parameters */
  assert_param(IS_CAN_IT(ActiveITs));

  if ((state == HAL_CAN_STATE_READY) ||
 800955c:	7bfb      	ldrb	r3, [r7, #15]
 800955e:	2b01      	cmp	r3, #1
 8009560:	d002      	beq.n	8009568 <HAL_CAN_ActivateNotification+0x1e>
 8009562:	7bfb      	ldrb	r3, [r7, #15]
 8009564:	2b02      	cmp	r3, #2
 8009566:	d109      	bne.n	800957c <HAL_CAN_ActivateNotification+0x32>
      (state == HAL_CAN_STATE_LISTENING))
  {
    /* Enable the selected interrupts */
    __HAL_CAN_ENABLE_IT(hcan, ActiveITs);
 8009568:	687b      	ldr	r3, [r7, #4]
 800956a:	681b      	ldr	r3, [r3, #0]
 800956c:	6959      	ldr	r1, [r3, #20]
 800956e:	687b      	ldr	r3, [r7, #4]
 8009570:	681b      	ldr	r3, [r3, #0]
 8009572:	683a      	ldr	r2, [r7, #0]
 8009574:	430a      	orrs	r2, r1
 8009576:	615a      	str	r2, [r3, #20]

    /* Return function status */
    return HAL_OK;
 8009578:	2300      	movs	r3, #0
 800957a:	e006      	b.n	800958a <HAL_CAN_ActivateNotification+0x40>
  }
  else
  {
    /* Update error code */
    hcan->ErrorCode |= HAL_CAN_ERROR_NOT_INITIALIZED;
 800957c:	687b      	ldr	r3, [r7, #4]
 800957e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8009580:	f443 2280 	orr.w	r2, r3, #262144	; 0x40000
 8009584:	687b      	ldr	r3, [r7, #4]
 8009586:	625a      	str	r2, [r3, #36]	; 0x24

    return HAL_ERROR;
 8009588:	2301      	movs	r3, #1
  }
}
 800958a:	4618      	mov	r0, r3
 800958c:	3714      	adds	r7, #20
 800958e:	46bd      	mov	sp, r7
 8009590:	bc80      	pop	{r7}
 8009592:	4770      	bx	lr

08009594 <HAL_CAN_IRQHandler>:
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
void HAL_CAN_IRQHandler(CAN_HandleTypeDef *hcan)
{
 8009594:	b580      	push	{r7, lr}
 8009596:	b08a      	sub	sp, #40	; 0x28
 8009598:	af00      	add	r7, sp, #0
 800959a:	6078      	str	r0, [r7, #4]
  uint32_t errorcode = HAL_CAN_ERROR_NONE;
 800959c:	2300      	movs	r3, #0
 800959e:	627b      	str	r3, [r7, #36]	; 0x24
  uint32_t interrupts = READ_REG(hcan->Instance->IER);
 80095a0:	687b      	ldr	r3, [r7, #4]
 80095a2:	681b      	ldr	r3, [r3, #0]
 80095a4:	695b      	ldr	r3, [r3, #20]
 80095a6:	623b      	str	r3, [r7, #32]
  uint32_t msrflags = READ_REG(hcan->Instance->MSR);
 80095a8:	687b      	ldr	r3, [r7, #4]
 80095aa:	681b      	ldr	r3, [r3, #0]
 80095ac:	685b      	ldr	r3, [r3, #4]
 80095ae:	61fb      	str	r3, [r7, #28]
  uint32_t tsrflags = READ_REG(hcan->Instance->TSR);
 80095b0:	687b      	ldr	r3, [r7, #4]
 80095b2:	681b      	ldr	r3, [r3, #0]
 80095b4:	689b      	ldr	r3, [r3, #8]
 80095b6:	61bb      	str	r3, [r7, #24]
  uint32_t rf0rflags = READ_REG(hcan->Instance->RF0R);
 80095b8:	687b      	ldr	r3, [r7, #4]
 80095ba:	681b      	ldr	r3, [r3, #0]
 80095bc:	68db      	ldr	r3, [r3, #12]
 80095be:	617b      	str	r3, [r7, #20]
  uint32_t rf1rflags = READ_REG(hcan->Instance->RF1R);
 80095c0:	687b      	ldr	r3, [r7, #4]
 80095c2:	681b      	ldr	r3, [r3, #0]
 80095c4:	691b      	ldr	r3, [r3, #16]
 80095c6:	613b      	str	r3, [r7, #16]
  uint32_t esrflags = READ_REG(hcan->Instance->ESR);
 80095c8:	687b      	ldr	r3, [r7, #4]
 80095ca:	681b      	ldr	r3, [r3, #0]
 80095cc:	699b      	ldr	r3, [r3, #24]
 80095ce:	60fb      	str	r3, [r7, #12]

  /* Transmit Mailbox empty interrupt management *****************************/
  if ((interrupts & CAN_IT_TX_MAILBOX_EMPTY) != 0U)
 80095d0:	6a3b      	ldr	r3, [r7, #32]
 80095d2:	f003 0301 	and.w	r3, r3, #1
 80095d6:	2b00      	cmp	r3, #0
 80095d8:	d07c      	beq.n	80096d4 <HAL_CAN_IRQHandler+0x140>
  {
    /* Transmit Mailbox 0 management *****************************************/
    if ((tsrflags & CAN_TSR_RQCP0) != 0U)
 80095da:	69bb      	ldr	r3, [r7, #24]
 80095dc:	f003 0301 	and.w	r3, r3, #1
 80095e0:	2b00      	cmp	r3, #0
 80095e2:	d023      	beq.n	800962c <HAL_CAN_IRQHandler+0x98>
    {
      /* Clear the Transmission Complete flag (and TXOK0,ALST0,TERR0 bits) */
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_RQCP0);
 80095e4:	687b      	ldr	r3, [r7, #4]
 80095e6:	681b      	ldr	r3, [r3, #0]
 80095e8:	2201      	movs	r2, #1
 80095ea:	609a      	str	r2, [r3, #8]

      if ((tsrflags & CAN_TSR_TXOK0) != 0U)
 80095ec:	69bb      	ldr	r3, [r7, #24]
 80095ee:	f003 0302 	and.w	r3, r3, #2
 80095f2:	2b00      	cmp	r3, #0
 80095f4:	d003      	beq.n	80095fe <HAL_CAN_IRQHandler+0x6a>
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
        /* Call registered callback*/
        hcan->TxMailbox0CompleteCallback(hcan);
#else
        /* Call weak (surcharged) callback */
        HAL_CAN_TxMailbox0CompleteCallback(hcan);
 80095f6:	6878      	ldr	r0, [r7, #4]
 80095f8:	f000 f97d 	bl	80098f6 <HAL_CAN_TxMailbox0CompleteCallback>
 80095fc:	e016      	b.n	800962c <HAL_CAN_IRQHandler+0x98>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
      }
      else
      {
        if ((tsrflags & CAN_TSR_ALST0) != 0U)
 80095fe:	69bb      	ldr	r3, [r7, #24]
 8009600:	f003 0304 	and.w	r3, r3, #4
 8009604:	2b00      	cmp	r3, #0
 8009606:	d004      	beq.n	8009612 <HAL_CAN_IRQHandler+0x7e>
        {
          /* Update error code */
          errorcode |= HAL_CAN_ERROR_TX_ALST0;
 8009608:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800960a:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 800960e:	627b      	str	r3, [r7, #36]	; 0x24
 8009610:	e00c      	b.n	800962c <HAL_CAN_IRQHandler+0x98>
        }
        else if ((tsrflags & CAN_TSR_TERR0) != 0U)
 8009612:	69bb      	ldr	r3, [r7, #24]
 8009614:	f003 0308 	and.w	r3, r3, #8
 8009618:	2b00      	cmp	r3, #0
 800961a:	d004      	beq.n	8009626 <HAL_CAN_IRQHandler+0x92>
        {
          /* Update error code */
          errorcode |= HAL_CAN_ERROR_TX_TERR0;
 800961c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800961e:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8009622:	627b      	str	r3, [r7, #36]	; 0x24
 8009624:	e002      	b.n	800962c <HAL_CAN_IRQHandler+0x98>
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
          /* Call registered callback*/
          hcan->TxMailbox0AbortCallback(hcan);
#else
          /* Call weak (surcharged) callback */
          HAL_CAN_TxMailbox0AbortCallback(hcan);
 8009626:	6878      	ldr	r0, [r7, #4]
 8009628:	f000 f980 	bl	800992c <HAL_CAN_TxMailbox0AbortCallback>
        }
      }
    }

    /* Transmit Mailbox 1 management *****************************************/
    if ((tsrflags & CAN_TSR_RQCP1) != 0U)
 800962c:	69bb      	ldr	r3, [r7, #24]
 800962e:	f403 7380 	and.w	r3, r3, #256	; 0x100
 8009632:	2b00      	cmp	r3, #0
 8009634:	d024      	beq.n	8009680 <HAL_CAN_IRQHandler+0xec>
    {
      /* Clear the Transmission Complete flag (and TXOK1,ALST1,TERR1 bits) */
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_RQCP1);
 8009636:	687b      	ldr	r3, [r7, #4]
 8009638:	681b      	ldr	r3, [r3, #0]
 800963a:	f44f 7280 	mov.w	r2, #256	; 0x100
 800963e:	609a      	str	r2, [r3, #8]

      if ((tsrflags & CAN_TSR_TXOK1) != 0U)
 8009640:	69bb      	ldr	r3, [r7, #24]
 8009642:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8009646:	2b00      	cmp	r3, #0
 8009648:	d003      	beq.n	8009652 <HAL_CAN_IRQHandler+0xbe>
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
        /* Call registered callback*/
        hcan->TxMailbox1CompleteCallback(hcan);
#else
        /* Call weak (surcharged) callback */
        HAL_CAN_TxMailbox1CompleteCallback(hcan);
 800964a:	6878      	ldr	r0, [r7, #4]
 800964c:	f000 f95c 	bl	8009908 <HAL_CAN_TxMailbox1CompleteCallback>
 8009650:	e016      	b.n	8009680 <HAL_CAN_IRQHandler+0xec>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
      }
      else
      {
        if ((tsrflags & CAN_TSR_ALST1) != 0U)
 8009652:	69bb      	ldr	r3, [r7, #24]
 8009654:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8009658:	2b00      	cmp	r3, #0
 800965a:	d004      	beq.n	8009666 <HAL_CAN_IRQHandler+0xd2>
        {
          /* Update error code */
          errorcode |= HAL_CAN_ERROR_TX_ALST1;
 800965c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800965e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8009662:	627b      	str	r3, [r7, #36]	; 0x24
 8009664:	e00c      	b.n	8009680 <HAL_CAN_IRQHandler+0xec>
        }
        else if ((tsrflags & CAN_TSR_TERR1) != 0U)
 8009666:	69bb      	ldr	r3, [r7, #24]
 8009668:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800966c:	2b00      	cmp	r3, #0
 800966e:	d004      	beq.n	800967a <HAL_CAN_IRQHandler+0xe6>
        {
          /* Update error code */
          errorcode |= HAL_CAN_ERROR_TX_TERR1;
 8009670:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009672:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8009676:	627b      	str	r3, [r7, #36]	; 0x24
 8009678:	e002      	b.n	8009680 <HAL_CAN_IRQHandler+0xec>
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
          /* Call registered callback*/
          hcan->TxMailbox1AbortCallback(hcan);
#else
          /* Call weak (surcharged) callback */
          HAL_CAN_TxMailbox1AbortCallback(hcan);
 800967a:	6878      	ldr	r0, [r7, #4]
 800967c:	f000 f95f 	bl	800993e <HAL_CAN_TxMailbox1AbortCallback>
        }
      }
    }

    /* Transmit Mailbox 2 management *****************************************/
    if ((tsrflags & CAN_TSR_RQCP2) != 0U)
 8009680:	69bb      	ldr	r3, [r7, #24]
 8009682:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8009686:	2b00      	cmp	r3, #0
 8009688:	d024      	beq.n	80096d4 <HAL_CAN_IRQHandler+0x140>
    {
      /* Clear the Transmission Complete flag (and TXOK2,ALST2,TERR2 bits) */
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_RQCP2);
 800968a:	687b      	ldr	r3, [r7, #4]
 800968c:	681b      	ldr	r3, [r3, #0]
 800968e:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8009692:	609a      	str	r2, [r3, #8]

      if ((tsrflags & CAN_TSR_TXOK2) != 0U)
 8009694:	69bb      	ldr	r3, [r7, #24]
 8009696:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800969a:	2b00      	cmp	r3, #0
 800969c:	d003      	beq.n	80096a6 <HAL_CAN_IRQHandler+0x112>
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
        /* Call registered callback*/
        hcan->TxMailbox2CompleteCallback(hcan);
#else
        /* Call weak (surcharged) callback */
        HAL_CAN_TxMailbox2CompleteCallback(hcan);
 800969e:	6878      	ldr	r0, [r7, #4]
 80096a0:	f000 f93b 	bl	800991a <HAL_CAN_TxMailbox2CompleteCallback>
 80096a4:	e016      	b.n	80096d4 <HAL_CAN_IRQHandler+0x140>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
      }
      else
      {
        if ((tsrflags & CAN_TSR_ALST2) != 0U)
 80096a6:	69bb      	ldr	r3, [r7, #24]
 80096a8:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 80096ac:	2b00      	cmp	r3, #0
 80096ae:	d004      	beq.n	80096ba <HAL_CAN_IRQHandler+0x126>
        {
          /* Update error code */
          errorcode |= HAL_CAN_ERROR_TX_ALST2;
 80096b0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80096b2:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 80096b6:	627b      	str	r3, [r7, #36]	; 0x24
 80096b8:	e00c      	b.n	80096d4 <HAL_CAN_IRQHandler+0x140>
        }
        else if ((tsrflags & CAN_TSR_TERR2) != 0U)
 80096ba:	69bb      	ldr	r3, [r7, #24]
 80096bc:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 80096c0:	2b00      	cmp	r3, #0
 80096c2:	d004      	beq.n	80096ce <HAL_CAN_IRQHandler+0x13a>
        {
          /* Update error code */
          errorcode |= HAL_CAN_ERROR_TX_TERR2;
 80096c4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80096c6:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 80096ca:	627b      	str	r3, [r7, #36]	; 0x24
 80096cc:	e002      	b.n	80096d4 <HAL_CAN_IRQHandler+0x140>
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
          /* Call registered callback*/
          hcan->TxMailbox2AbortCallback(hcan);
#else
          /* Call weak (surcharged) callback */
          HAL_CAN_TxMailbox2AbortCallback(hcan);
 80096ce:	6878      	ldr	r0, [r7, #4]
 80096d0:	f000 f93e 	bl	8009950 <HAL_CAN_TxMailbox2AbortCallback>
      }
    }
  }

  /* Receive FIFO 0 overrun interrupt management *****************************/
  if ((interrupts & CAN_IT_RX_FIFO0_OVERRUN) != 0U)
 80096d4:	6a3b      	ldr	r3, [r7, #32]
 80096d6:	f003 0308 	and.w	r3, r3, #8
 80096da:	2b00      	cmp	r3, #0
 80096dc:	d00c      	beq.n	80096f8 <HAL_CAN_IRQHandler+0x164>
  {
    if ((rf0rflags & CAN_RF0R_FOVR0) != 0U)
 80096de:	697b      	ldr	r3, [r7, #20]
 80096e0:	f003 0310 	and.w	r3, r3, #16
 80096e4:	2b00      	cmp	r3, #0
 80096e6:	d007      	beq.n	80096f8 <HAL_CAN_IRQHandler+0x164>
    {
      /* Set CAN error code to Rx Fifo 0 overrun error */
      errorcode |= HAL_CAN_ERROR_RX_FOV0;
 80096e8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80096ea:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 80096ee:	627b      	str	r3, [r7, #36]	; 0x24

      /* Clear FIFO0 Overrun Flag */
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FOV0);
 80096f0:	687b      	ldr	r3, [r7, #4]
 80096f2:	681b      	ldr	r3, [r3, #0]
 80096f4:	2210      	movs	r2, #16
 80096f6:	60da      	str	r2, [r3, #12]
    }
  }

  /* Receive FIFO 0 full interrupt management ********************************/
  if ((interrupts & CAN_IT_RX_FIFO0_FULL) != 0U)
 80096f8:	6a3b      	ldr	r3, [r7, #32]
 80096fa:	f003 0304 	and.w	r3, r3, #4
 80096fe:	2b00      	cmp	r3, #0
 8009700:	d00b      	beq.n	800971a <HAL_CAN_IRQHandler+0x186>
  {
    if ((rf0rflags & CAN_RF0R_FULL0) != 0U)
 8009702:	697b      	ldr	r3, [r7, #20]
 8009704:	f003 0308 	and.w	r3, r3, #8
 8009708:	2b00      	cmp	r3, #0
 800970a:	d006      	beq.n	800971a <HAL_CAN_IRQHandler+0x186>
    {
      /* Clear FIFO 0 full Flag */
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FF0);
 800970c:	687b      	ldr	r3, [r7, #4]
 800970e:	681b      	ldr	r3, [r3, #0]
 8009710:	2208      	movs	r2, #8
 8009712:	60da      	str	r2, [r3, #12]
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
      /* Call registered callback*/
      hcan->RxFifo0FullCallback(hcan);
#else
      /* Call weak (surcharged) callback */
      HAL_CAN_RxFifo0FullCallback(hcan);
 8009714:	6878      	ldr	r0, [r7, #4]
 8009716:	f000 f924 	bl	8009962 <HAL_CAN_RxFifo0FullCallback>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
    }
  }

  /* Receive FIFO 0 message pending interrupt management *********************/
  if ((interrupts & CAN_IT_RX_FIFO0_MSG_PENDING) != 0U)
 800971a:	6a3b      	ldr	r3, [r7, #32]
 800971c:	f003 0302 	and.w	r3, r3, #2
 8009720:	2b00      	cmp	r3, #0
 8009722:	d009      	beq.n	8009738 <HAL_CAN_IRQHandler+0x1a4>
  {
    /* Check if message is still pending */
    if ((hcan->Instance->RF0R & CAN_RF0R_FMP0) != 0U)
 8009724:	687b      	ldr	r3, [r7, #4]
 8009726:	681b      	ldr	r3, [r3, #0]
 8009728:	68db      	ldr	r3, [r3, #12]
 800972a:	f003 0303 	and.w	r3, r3, #3
 800972e:	2b00      	cmp	r3, #0
 8009730:	d002      	beq.n	8009738 <HAL_CAN_IRQHandler+0x1a4>
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
      /* Call registered callback*/
      hcan->RxFifo0MsgPendingCallback(hcan);
#else
      /* Call weak (surcharged) callback */
      HAL_CAN_RxFifo0MsgPendingCallback(hcan);
 8009732:	6878      	ldr	r0, [r7, #4]
 8009734:	f7ff fa1c 	bl	8008b70 <HAL_CAN_RxFifo0MsgPendingCallback>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
    }
  }

  /* Receive FIFO 1 overrun interrupt management *****************************/
  if ((interrupts & CAN_IT_RX_FIFO1_OVERRUN) != 0U)
 8009738:	6a3b      	ldr	r3, [r7, #32]
 800973a:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800973e:	2b00      	cmp	r3, #0
 8009740:	d00c      	beq.n	800975c <HAL_CAN_IRQHandler+0x1c8>
  {
    if ((rf1rflags & CAN_RF1R_FOVR1) != 0U)
 8009742:	693b      	ldr	r3, [r7, #16]
 8009744:	f003 0310 	and.w	r3, r3, #16
 8009748:	2b00      	cmp	r3, #0
 800974a:	d007      	beq.n	800975c <HAL_CAN_IRQHandler+0x1c8>
    {
      /* Set CAN error code to Rx Fifo 1 overrun error */
      errorcode |= HAL_CAN_ERROR_RX_FOV1;
 800974c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800974e:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8009752:	627b      	str	r3, [r7, #36]	; 0x24

      /* Clear FIFO1 Overrun Flag */
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FOV1);
 8009754:	687b      	ldr	r3, [r7, #4]
 8009756:	681b      	ldr	r3, [r3, #0]
 8009758:	2210      	movs	r2, #16
 800975a:	611a      	str	r2, [r3, #16]
    }
  }

  /* Receive FIFO 1 full interrupt management ********************************/
  if ((interrupts & CAN_IT_RX_FIFO1_FULL) != 0U)
 800975c:	6a3b      	ldr	r3, [r7, #32]
 800975e:	f003 0320 	and.w	r3, r3, #32
 8009762:	2b00      	cmp	r3, #0
 8009764:	d00b      	beq.n	800977e <HAL_CAN_IRQHandler+0x1ea>
  {
    if ((rf1rflags & CAN_RF1R_FULL1) != 0U)
 8009766:	693b      	ldr	r3, [r7, #16]
 8009768:	f003 0308 	and.w	r3, r3, #8
 800976c:	2b00      	cmp	r3, #0
 800976e:	d006      	beq.n	800977e <HAL_CAN_IRQHandler+0x1ea>
    {
      /* Clear FIFO 1 full Flag */
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_FF1);
 8009770:	687b      	ldr	r3, [r7, #4]
 8009772:	681b      	ldr	r3, [r3, #0]
 8009774:	2208      	movs	r2, #8
 8009776:	611a      	str	r2, [r3, #16]
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
      /* Call registered callback*/
      hcan->RxFifo1FullCallback(hcan);
#else
      /* Call weak (surcharged) callback */
      HAL_CAN_RxFifo1FullCallback(hcan);
 8009778:	6878      	ldr	r0, [r7, #4]
 800977a:	f000 f904 	bl	8009986 <HAL_CAN_RxFifo1FullCallback>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
    }
  }

  /* Receive FIFO 1 message pending interrupt management *********************/
  if ((interrupts & CAN_IT_RX_FIFO1_MSG_PENDING) != 0U)
 800977e:	6a3b      	ldr	r3, [r7, #32]
 8009780:	f003 0310 	and.w	r3, r3, #16
 8009784:	2b00      	cmp	r3, #0
 8009786:	d009      	beq.n	800979c <HAL_CAN_IRQHandler+0x208>
  {
    /* Check if message is still pending */
    if ((hcan->Instance->RF1R & CAN_RF1R_FMP1) != 0U)
 8009788:	687b      	ldr	r3, [r7, #4]
 800978a:	681b      	ldr	r3, [r3, #0]
 800978c:	691b      	ldr	r3, [r3, #16]
 800978e:	f003 0303 	and.w	r3, r3, #3
 8009792:	2b00      	cmp	r3, #0
 8009794:	d002      	beq.n	800979c <HAL_CAN_IRQHandler+0x208>
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
      /* Call registered callback*/
      hcan->RxFifo1MsgPendingCallback(hcan);
#else
      /* Call weak (surcharged) callback */
      HAL_CAN_RxFifo1MsgPendingCallback(hcan);
 8009796:	6878      	ldr	r0, [r7, #4]
 8009798:	f000 f8ec 	bl	8009974 <HAL_CAN_RxFifo1MsgPendingCallback>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
    }
  }

  /* Sleep interrupt management *********************************************/
  if ((interrupts & CAN_IT_SLEEP_ACK) != 0U)
 800979c:	6a3b      	ldr	r3, [r7, #32]
 800979e:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 80097a2:	2b00      	cmp	r3, #0
 80097a4:	d00b      	beq.n	80097be <HAL_CAN_IRQHandler+0x22a>
  {
    if ((msrflags & CAN_MSR_SLAKI) != 0U)
 80097a6:	69fb      	ldr	r3, [r7, #28]
 80097a8:	f003 0310 	and.w	r3, r3, #16
 80097ac:	2b00      	cmp	r3, #0
 80097ae:	d006      	beq.n	80097be <HAL_CAN_IRQHandler+0x22a>
    {
      /* Clear Sleep interrupt Flag */
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_SLAKI);
 80097b0:	687b      	ldr	r3, [r7, #4]
 80097b2:	681b      	ldr	r3, [r3, #0]
 80097b4:	2210      	movs	r2, #16
 80097b6:	605a      	str	r2, [r3, #4]
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
      /* Call registered callback*/
      hcan->SleepCallback(hcan);
#else
      /* Call weak (surcharged) callback */
      HAL_CAN_SleepCallback(hcan);
 80097b8:	6878      	ldr	r0, [r7, #4]
 80097ba:	f000 f8ed 	bl	8009998 <HAL_CAN_SleepCallback>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
    }
  }

  /* WakeUp interrupt management *********************************************/
  if ((interrupts & CAN_IT_WAKEUP) != 0U)
 80097be:	6a3b      	ldr	r3, [r7, #32]
 80097c0:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 80097c4:	2b00      	cmp	r3, #0
 80097c6:	d00b      	beq.n	80097e0 <HAL_CAN_IRQHandler+0x24c>
  {
    if ((msrflags & CAN_MSR_WKUI) != 0U)
 80097c8:	69fb      	ldr	r3, [r7, #28]
 80097ca:	f003 0308 	and.w	r3, r3, #8
 80097ce:	2b00      	cmp	r3, #0
 80097d0:	d006      	beq.n	80097e0 <HAL_CAN_IRQHandler+0x24c>
    {
      /* Clear WakeUp Flag */
      __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_WKU);
 80097d2:	687b      	ldr	r3, [r7, #4]
 80097d4:	681b      	ldr	r3, [r3, #0]
 80097d6:	2208      	movs	r2, #8
 80097d8:	605a      	str	r2, [r3, #4]
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
      /* Call registered callback*/
      hcan->WakeUpFromRxMsgCallback(hcan);
#else
      /* Call weak (surcharged) callback */
      HAL_CAN_WakeUpFromRxMsgCallback(hcan);
 80097da:	6878      	ldr	r0, [r7, #4]
 80097dc:	f000 f8e5 	bl	80099aa <HAL_CAN_WakeUpFromRxMsgCallback>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
    }
  }

  /* Error interrupts management *********************************************/
  if ((interrupts & CAN_IT_ERROR) != 0U)
 80097e0:	6a3b      	ldr	r3, [r7, #32]
 80097e2:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 80097e6:	2b00      	cmp	r3, #0
 80097e8:	d075      	beq.n	80098d6 <HAL_CAN_IRQHandler+0x342>
  {
    if ((msrflags & CAN_MSR_ERRI) != 0U)
 80097ea:	69fb      	ldr	r3, [r7, #28]
 80097ec:	f003 0304 	and.w	r3, r3, #4
 80097f0:	2b00      	cmp	r3, #0
 80097f2:	d06c      	beq.n	80098ce <HAL_CAN_IRQHandler+0x33a>
    {
      /* Check Error Warning Flag */
      if (((interrupts & CAN_IT_ERROR_WARNING) != 0U) &&
 80097f4:	6a3b      	ldr	r3, [r7, #32]
 80097f6:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80097fa:	2b00      	cmp	r3, #0
 80097fc:	d008      	beq.n	8009810 <HAL_CAN_IRQHandler+0x27c>
          ((esrflags & CAN_ESR_EWGF) != 0U))
 80097fe:	68fb      	ldr	r3, [r7, #12]
 8009800:	f003 0301 	and.w	r3, r3, #1
      if (((interrupts & CAN_IT_ERROR_WARNING) != 0U) &&
 8009804:	2b00      	cmp	r3, #0
 8009806:	d003      	beq.n	8009810 <HAL_CAN_IRQHandler+0x27c>
      {
        /* Set CAN error code to Error Warning */
        errorcode |= HAL_CAN_ERROR_EWG;
 8009808:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800980a:	f043 0301 	orr.w	r3, r3, #1
 800980e:	627b      	str	r3, [r7, #36]	; 0x24

        /* No need for clear of Error Warning Flag as read-only */
      }

      /* Check Error Passive Flag */
      if (((interrupts & CAN_IT_ERROR_PASSIVE) != 0U) &&
 8009810:	6a3b      	ldr	r3, [r7, #32]
 8009812:	f403 7300 	and.w	r3, r3, #512	; 0x200
 8009816:	2b00      	cmp	r3, #0
 8009818:	d008      	beq.n	800982c <HAL_CAN_IRQHandler+0x298>
          ((esrflags & CAN_ESR_EPVF) != 0U))
 800981a:	68fb      	ldr	r3, [r7, #12]
 800981c:	f003 0302 	and.w	r3, r3, #2
      if (((interrupts & CAN_IT_ERROR_PASSIVE) != 0U) &&
 8009820:	2b00      	cmp	r3, #0
 8009822:	d003      	beq.n	800982c <HAL_CAN_IRQHandler+0x298>
      {
        /* Set CAN error code to Error Passive */
        errorcode |= HAL_CAN_ERROR_EPV;
 8009824:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009826:	f043 0302 	orr.w	r3, r3, #2
 800982a:	627b      	str	r3, [r7, #36]	; 0x24

        /* No need for clear of Error Passive Flag as read-only */
      }

      /* Check Bus-off Flag */
      if (((interrupts & CAN_IT_BUSOFF) != 0U) &&
 800982c:	6a3b      	ldr	r3, [r7, #32]
 800982e:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8009832:	2b00      	cmp	r3, #0
 8009834:	d008      	beq.n	8009848 <HAL_CAN_IRQHandler+0x2b4>
          ((esrflags & CAN_ESR_BOFF) != 0U))
 8009836:	68fb      	ldr	r3, [r7, #12]
 8009838:	f003 0304 	and.w	r3, r3, #4
      if (((interrupts & CAN_IT_BUSOFF) != 0U) &&
 800983c:	2b00      	cmp	r3, #0
 800983e:	d003      	beq.n	8009848 <HAL_CAN_IRQHandler+0x2b4>
      {
        /* Set CAN error code to Bus-Off */
        errorcode |= HAL_CAN_ERROR_BOF;
 8009840:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009842:	f043 0304 	orr.w	r3, r3, #4
 8009846:	627b      	str	r3, [r7, #36]	; 0x24

        /* No need for clear of Error Bus-Off as read-only */
      }

      /* Check Last Error Code Flag */
      if (((interrupts & CAN_IT_LAST_ERROR_CODE) != 0U) &&
 8009848:	6a3b      	ldr	r3, [r7, #32]
 800984a:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800984e:	2b00      	cmp	r3, #0
 8009850:	d03d      	beq.n	80098ce <HAL_CAN_IRQHandler+0x33a>
          ((esrflags & CAN_ESR_LEC) != 0U))
 8009852:	68fb      	ldr	r3, [r7, #12]
 8009854:	f003 0370 	and.w	r3, r3, #112	; 0x70
      if (((interrupts & CAN_IT_LAST_ERROR_CODE) != 0U) &&
 8009858:	2b00      	cmp	r3, #0
 800985a:	d038      	beq.n	80098ce <HAL_CAN_IRQHandler+0x33a>
      {
        switch (esrflags & CAN_ESR_LEC)
 800985c:	68fb      	ldr	r3, [r7, #12]
 800985e:	f003 0370 	and.w	r3, r3, #112	; 0x70
 8009862:	2b30      	cmp	r3, #48	; 0x30
 8009864:	d017      	beq.n	8009896 <HAL_CAN_IRQHandler+0x302>
 8009866:	2b30      	cmp	r3, #48	; 0x30
 8009868:	d804      	bhi.n	8009874 <HAL_CAN_IRQHandler+0x2e0>
 800986a:	2b10      	cmp	r3, #16
 800986c:	d009      	beq.n	8009882 <HAL_CAN_IRQHandler+0x2ee>
 800986e:	2b20      	cmp	r3, #32
 8009870:	d00c      	beq.n	800988c <HAL_CAN_IRQHandler+0x2f8>
          case (CAN_ESR_LEC_2 | CAN_ESR_LEC_1):
            /* Set CAN error code to CRC error */
            errorcode |= HAL_CAN_ERROR_CRC;
            break;
          default:
            break;
 8009872:	e024      	b.n	80098be <HAL_CAN_IRQHandler+0x32a>
        switch (esrflags & CAN_ESR_LEC)
 8009874:	2b50      	cmp	r3, #80	; 0x50
 8009876:	d018      	beq.n	80098aa <HAL_CAN_IRQHandler+0x316>
 8009878:	2b60      	cmp	r3, #96	; 0x60
 800987a:	d01b      	beq.n	80098b4 <HAL_CAN_IRQHandler+0x320>
 800987c:	2b40      	cmp	r3, #64	; 0x40
 800987e:	d00f      	beq.n	80098a0 <HAL_CAN_IRQHandler+0x30c>
            break;
 8009880:	e01d      	b.n	80098be <HAL_CAN_IRQHandler+0x32a>
            errorcode |= HAL_CAN_ERROR_STF;
 8009882:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009884:	f043 0308 	orr.w	r3, r3, #8
 8009888:	627b      	str	r3, [r7, #36]	; 0x24
            break;
 800988a:	e018      	b.n	80098be <HAL_CAN_IRQHandler+0x32a>
            errorcode |= HAL_CAN_ERROR_FOR;
 800988c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800988e:	f043 0310 	orr.w	r3, r3, #16
 8009892:	627b      	str	r3, [r7, #36]	; 0x24
            break;
 8009894:	e013      	b.n	80098be <HAL_CAN_IRQHandler+0x32a>
            errorcode |= HAL_CAN_ERROR_ACK;
 8009896:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009898:	f043 0320 	orr.w	r3, r3, #32
 800989c:	627b      	str	r3, [r7, #36]	; 0x24
            break;
 800989e:	e00e      	b.n	80098be <HAL_CAN_IRQHandler+0x32a>
            errorcode |= HAL_CAN_ERROR_BR;
 80098a0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80098a2:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80098a6:	627b      	str	r3, [r7, #36]	; 0x24
            break;
 80098a8:	e009      	b.n	80098be <HAL_CAN_IRQHandler+0x32a>
            errorcode |= HAL_CAN_ERROR_BD;
 80098aa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80098ac:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80098b0:	627b      	str	r3, [r7, #36]	; 0x24
            break;
 80098b2:	e004      	b.n	80098be <HAL_CAN_IRQHandler+0x32a>
            errorcode |= HAL_CAN_ERROR_CRC;
 80098b4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80098b6:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80098ba:	627b      	str	r3, [r7, #36]	; 0x24
            break;
 80098bc:	bf00      	nop
        }

        /* Clear Last error code Flag */
        CLEAR_BIT(hcan->Instance->ESR, CAN_ESR_LEC);
 80098be:	687b      	ldr	r3, [r7, #4]
 80098c0:	681b      	ldr	r3, [r3, #0]
 80098c2:	699a      	ldr	r2, [r3, #24]
 80098c4:	687b      	ldr	r3, [r7, #4]
 80098c6:	681b      	ldr	r3, [r3, #0]
 80098c8:	f022 0270 	bic.w	r2, r2, #112	; 0x70
 80098cc:	619a      	str	r2, [r3, #24]
      }
    }

    /* Clear ERRI Flag */
    __HAL_CAN_CLEAR_FLAG(hcan, CAN_FLAG_ERRI);
 80098ce:	687b      	ldr	r3, [r7, #4]
 80098d0:	681b      	ldr	r3, [r3, #0]
 80098d2:	2204      	movs	r2, #4
 80098d4:	605a      	str	r2, [r3, #4]
  }

  /* Call the Error call Back in case of Errors */
  if (errorcode != HAL_CAN_ERROR_NONE)
 80098d6:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80098d8:	2b00      	cmp	r3, #0
 80098da:	d008      	beq.n	80098ee <HAL_CAN_IRQHandler+0x35a>
  {
    /* Update error code in handle */
    hcan->ErrorCode |= errorcode;
 80098dc:	687b      	ldr	r3, [r7, #4]
 80098de:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80098e0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80098e2:	431a      	orrs	r2, r3
 80098e4:	687b      	ldr	r3, [r7, #4]
 80098e6:	625a      	str	r2, [r3, #36]	; 0x24
#if USE_HAL_CAN_REGISTER_CALLBACKS == 1
    /* Call registered callback*/
    hcan->ErrorCallback(hcan);
#else
    /* Call weak (surcharged) callback */
    HAL_CAN_ErrorCallback(hcan);
 80098e8:	6878      	ldr	r0, [r7, #4]
 80098ea:	f000 f867 	bl	80099bc <HAL_CAN_ErrorCallback>
#endif /* USE_HAL_CAN_REGISTER_CALLBACKS */
  }
}
 80098ee:	bf00      	nop
 80098f0:	3728      	adds	r7, #40	; 0x28
 80098f2:	46bd      	mov	sp, r7
 80098f4:	bd80      	pop	{r7, pc}

080098f6 <HAL_CAN_TxMailbox0CompleteCallback>:
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_TxMailbox0CompleteCallback(CAN_HandleTypeDef *hcan)
{
 80098f6:	b480      	push	{r7}
 80098f8:	b083      	sub	sp, #12
 80098fa:	af00      	add	r7, sp, #0
 80098fc:	6078      	str	r0, [r7, #4]

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_TxMailbox0CompleteCallback could be implemented in the
            user file
   */
}
 80098fe:	bf00      	nop
 8009900:	370c      	adds	r7, #12
 8009902:	46bd      	mov	sp, r7
 8009904:	bc80      	pop	{r7}
 8009906:	4770      	bx	lr

08009908 <HAL_CAN_TxMailbox1CompleteCallback>:
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_TxMailbox1CompleteCallback(CAN_HandleTypeDef *hcan)
{
 8009908:	b480      	push	{r7}
 800990a:	b083      	sub	sp, #12
 800990c:	af00      	add	r7, sp, #0
 800990e:	6078      	str	r0, [r7, #4]

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_TxMailbox1CompleteCallback could be implemented in the
            user file
   */
}
 8009910:	bf00      	nop
 8009912:	370c      	adds	r7, #12
 8009914:	46bd      	mov	sp, r7
 8009916:	bc80      	pop	{r7}
 8009918:	4770      	bx	lr

0800991a <HAL_CAN_TxMailbox2CompleteCallback>:
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_TxMailbox2CompleteCallback(CAN_HandleTypeDef *hcan)
{
 800991a:	b480      	push	{r7}
 800991c:	b083      	sub	sp, #12
 800991e:	af00      	add	r7, sp, #0
 8009920:	6078      	str	r0, [r7, #4]

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_TxMailbox2CompleteCallback could be implemented in the
            user file
   */
}
 8009922:	bf00      	nop
 8009924:	370c      	adds	r7, #12
 8009926:	46bd      	mov	sp, r7
 8009928:	bc80      	pop	{r7}
 800992a:	4770      	bx	lr

0800992c <HAL_CAN_TxMailbox0AbortCallback>:
  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_TxMailbox0AbortCallback(CAN_HandleTypeDef *hcan)
{
 800992c:	b480      	push	{r7}
 800992e:	b083      	sub	sp, #12
 8009930:	af00      	add	r7, sp, #0
 8009932:	6078      	str	r0, [r7, #4]

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_TxMailbox0AbortCallback could be implemented in the
            user file
   */
}
 8009934:	bf00      	nop
 8009936:	370c      	adds	r7, #12
 8009938:	46bd      	mov	sp, r7
 800993a:	bc80      	pop	{r7}
 800993c:	4770      	bx	lr

0800993e <HAL_CAN_TxMailbox1AbortCallback>:
  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_TxMailbox1AbortCallback(CAN_HandleTypeDef *hcan)
{
 800993e:	b480      	push	{r7}
 8009940:	b083      	sub	sp, #12
 8009942:	af00      	add	r7, sp, #0
 8009944:	6078      	str	r0, [r7, #4]

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_TxMailbox1AbortCallback could be implemented in the
            user file
   */
}
 8009946:	bf00      	nop
 8009948:	370c      	adds	r7, #12
 800994a:	46bd      	mov	sp, r7
 800994c:	bc80      	pop	{r7}
 800994e:	4770      	bx	lr

08009950 <HAL_CAN_TxMailbox2AbortCallback>:
  * @param  hcan pointer to an CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_TxMailbox2AbortCallback(CAN_HandleTypeDef *hcan)
{
 8009950:	b480      	push	{r7}
 8009952:	b083      	sub	sp, #12
 8009954:	af00      	add	r7, sp, #0
 8009956:	6078      	str	r0, [r7, #4]

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_TxMailbox2AbortCallback could be implemented in the
            user file
   */
}
 8009958:	bf00      	nop
 800995a:	370c      	adds	r7, #12
 800995c:	46bd      	mov	sp, r7
 800995e:	bc80      	pop	{r7}
 8009960:	4770      	bx	lr

08009962 <HAL_CAN_RxFifo0FullCallback>:
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_RxFifo0FullCallback(CAN_HandleTypeDef *hcan)
{
 8009962:	b480      	push	{r7}
 8009964:	b083      	sub	sp, #12
 8009966:	af00      	add	r7, sp, #0
 8009968:	6078      	str	r0, [r7, #4]

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_RxFifo0FullCallback could be implemented in the user
            file
   */
}
 800996a:	bf00      	nop
 800996c:	370c      	adds	r7, #12
 800996e:	46bd      	mov	sp, r7
 8009970:	bc80      	pop	{r7}
 8009972:	4770      	bx	lr

08009974 <HAL_CAN_RxFifo1MsgPendingCallback>:
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_RxFifo1MsgPendingCallback(CAN_HandleTypeDef *hcan)
{
 8009974:	b480      	push	{r7}
 8009976:	b083      	sub	sp, #12
 8009978:	af00      	add	r7, sp, #0
 800997a:	6078      	str	r0, [r7, #4]

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_RxFifo1MsgPendingCallback could be implemented in the
            user file
   */
}
 800997c:	bf00      	nop
 800997e:	370c      	adds	r7, #12
 8009980:	46bd      	mov	sp, r7
 8009982:	bc80      	pop	{r7}
 8009984:	4770      	bx	lr

08009986 <HAL_CAN_RxFifo1FullCallback>:
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_RxFifo1FullCallback(CAN_HandleTypeDef *hcan)
{
 8009986:	b480      	push	{r7}
 8009988:	b083      	sub	sp, #12
 800998a:	af00      	add	r7, sp, #0
 800998c:	6078      	str	r0, [r7, #4]

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_RxFifo1FullCallback could be implemented in the user
            file
   */
}
 800998e:	bf00      	nop
 8009990:	370c      	adds	r7, #12
 8009992:	46bd      	mov	sp, r7
 8009994:	bc80      	pop	{r7}
 8009996:	4770      	bx	lr

08009998 <HAL_CAN_SleepCallback>:
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_SleepCallback(CAN_HandleTypeDef *hcan)
{
 8009998:	b480      	push	{r7}
 800999a:	b083      	sub	sp, #12
 800999c:	af00      	add	r7, sp, #0
 800999e:	6078      	str	r0, [r7, #4]
  UNUSED(hcan);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_SleepCallback could be implemented in the user file
   */
}
 80099a0:	bf00      	nop
 80099a2:	370c      	adds	r7, #12
 80099a4:	46bd      	mov	sp, r7
 80099a6:	bc80      	pop	{r7}
 80099a8:	4770      	bx	lr

080099aa <HAL_CAN_WakeUpFromRxMsgCallback>:
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_WakeUpFromRxMsgCallback(CAN_HandleTypeDef *hcan)
{
 80099aa:	b480      	push	{r7}
 80099ac:	b083      	sub	sp, #12
 80099ae:	af00      	add	r7, sp, #0
 80099b0:	6078      	str	r0, [r7, #4]

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_WakeUpFromRxMsgCallback could be implemented in the
            user file
   */
}
 80099b2:	bf00      	nop
 80099b4:	370c      	adds	r7, #12
 80099b6:	46bd      	mov	sp, r7
 80099b8:	bc80      	pop	{r7}
 80099ba:	4770      	bx	lr

080099bc <HAL_CAN_ErrorCallback>:
  * @param  hcan pointer to a CAN_HandleTypeDef structure that contains
  *         the configuration information for the specified CAN.
  * @retval None
  */
__weak void HAL_CAN_ErrorCallback(CAN_HandleTypeDef *hcan)
{
 80099bc:	b480      	push	{r7}
 80099be:	b083      	sub	sp, #12
 80099c0:	af00      	add	r7, sp, #0
 80099c2:	6078      	str	r0, [r7, #4]
  UNUSED(hcan);

  /* NOTE : This function Should not be modified, when the callback is needed,
            the HAL_CAN_ErrorCallback could be implemented in the user file
   */
}
 80099c4:	bf00      	nop
 80099c6:	370c      	adds	r7, #12
 80099c8:	46bd      	mov	sp, r7
 80099ca:	bc80      	pop	{r7}
 80099cc:	4770      	bx	lr
	...

080099d0 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80099d0:	b480      	push	{r7}
 80099d2:	b085      	sub	sp, #20
 80099d4:	af00      	add	r7, sp, #0
 80099d6:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 80099d8:	687b      	ldr	r3, [r7, #4]
 80099da:	f003 0307 	and.w	r3, r3, #7
 80099de:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80099e0:	4b0c      	ldr	r3, [pc, #48]	; (8009a14 <__NVIC_SetPriorityGrouping+0x44>)
 80099e2:	68db      	ldr	r3, [r3, #12]
 80099e4:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80099e6:	68ba      	ldr	r2, [r7, #8]
 80099e8:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 80099ec:	4013      	ands	r3, r2
 80099ee:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos) );               /* Insert write key and priority group */
 80099f0:	68fb      	ldr	r3, [r7, #12]
 80099f2:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80099f4:	68bb      	ldr	r3, [r7, #8]
 80099f6:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 80099f8:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80099fc:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8009a00:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 8009a02:	4a04      	ldr	r2, [pc, #16]	; (8009a14 <__NVIC_SetPriorityGrouping+0x44>)
 8009a04:	68bb      	ldr	r3, [r7, #8]
 8009a06:	60d3      	str	r3, [r2, #12]
}
 8009a08:	bf00      	nop
 8009a0a:	3714      	adds	r7, #20
 8009a0c:	46bd      	mov	sp, r7
 8009a0e:	bc80      	pop	{r7}
 8009a10:	4770      	bx	lr
 8009a12:	bf00      	nop
 8009a14:	e000ed00 	.word	0xe000ed00

08009a18 <__NVIC_GetPriorityGrouping>:
  \brief   Get Priority Grouping
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
 8009a18:	b480      	push	{r7}
 8009a1a:	af00      	add	r7, sp, #0
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 8009a1c:	4b04      	ldr	r3, [pc, #16]	; (8009a30 <__NVIC_GetPriorityGrouping+0x18>)
 8009a1e:	68db      	ldr	r3, [r3, #12]
 8009a20:	0a1b      	lsrs	r3, r3, #8
 8009a22:	f003 0307 	and.w	r3, r3, #7
}
 8009a26:	4618      	mov	r0, r3
 8009a28:	46bd      	mov	sp, r7
 8009a2a:	bc80      	pop	{r7}
 8009a2c:	4770      	bx	lr
 8009a2e:	bf00      	nop
 8009a30:	e000ed00 	.word	0xe000ed00

08009a34 <__NVIC_EnableIRQ>:
  \details Enables a device specific interrupt in the NVIC interrupt controller.
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8009a34:	b480      	push	{r7}
 8009a36:	b083      	sub	sp, #12
 8009a38:	af00      	add	r7, sp, #0
 8009a3a:	4603      	mov	r3, r0
 8009a3c:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8009a3e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8009a42:	2b00      	cmp	r3, #0
 8009a44:	db0b      	blt.n	8009a5e <__NVIC_EnableIRQ+0x2a>
  {
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8009a46:	79fb      	ldrb	r3, [r7, #7]
 8009a48:	f003 021f 	and.w	r2, r3, #31
 8009a4c:	4906      	ldr	r1, [pc, #24]	; (8009a68 <__NVIC_EnableIRQ+0x34>)
 8009a4e:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8009a52:	095b      	lsrs	r3, r3, #5
 8009a54:	2001      	movs	r0, #1
 8009a56:	fa00 f202 	lsl.w	r2, r0, r2
 8009a5a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  }
}
 8009a5e:	bf00      	nop
 8009a60:	370c      	adds	r7, #12
 8009a62:	46bd      	mov	sp, r7
 8009a64:	bc80      	pop	{r7}
 8009a66:	4770      	bx	lr
 8009a68:	e000e100 	.word	0xe000e100

08009a6c <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8009a6c:	b480      	push	{r7}
 8009a6e:	b083      	sub	sp, #12
 8009a70:	af00      	add	r7, sp, #0
 8009a72:	4603      	mov	r3, r0
 8009a74:	6039      	str	r1, [r7, #0]
 8009a76:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 8009a78:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8009a7c:	2b00      	cmp	r3, #0
 8009a7e:	db0a      	blt.n	8009a96 <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8009a80:	683b      	ldr	r3, [r7, #0]
 8009a82:	b2da      	uxtb	r2, r3
 8009a84:	490c      	ldr	r1, [pc, #48]	; (8009ab8 <__NVIC_SetPriority+0x4c>)
 8009a86:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8009a8a:	0112      	lsls	r2, r2, #4
 8009a8c:	b2d2      	uxtb	r2, r2
 8009a8e:	440b      	add	r3, r1
 8009a90:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8009a94:	e00a      	b.n	8009aac <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8009a96:	683b      	ldr	r3, [r7, #0]
 8009a98:	b2da      	uxtb	r2, r3
 8009a9a:	4908      	ldr	r1, [pc, #32]	; (8009abc <__NVIC_SetPriority+0x50>)
 8009a9c:	79fb      	ldrb	r3, [r7, #7]
 8009a9e:	f003 030f 	and.w	r3, r3, #15
 8009aa2:	3b04      	subs	r3, #4
 8009aa4:	0112      	lsls	r2, r2, #4
 8009aa6:	b2d2      	uxtb	r2, r2
 8009aa8:	440b      	add	r3, r1
 8009aaa:	761a      	strb	r2, [r3, #24]
}
 8009aac:	bf00      	nop
 8009aae:	370c      	adds	r7, #12
 8009ab0:	46bd      	mov	sp, r7
 8009ab2:	bc80      	pop	{r7}
 8009ab4:	4770      	bx	lr
 8009ab6:	bf00      	nop
 8009ab8:	e000e100 	.word	0xe000e100
 8009abc:	e000ed00 	.word	0xe000ed00

08009ac0 <NVIC_EncodePriority>:
  \param [in]   PreemptPriority  Preemptive priority value (starting from 0).
  \param [in]       SubPriority  Subpriority value (starting from 0).
  \return                        Encoded priority. Value can be used in the function \ref NVIC_SetPriority().
 */
__STATIC_INLINE uint32_t NVIC_EncodePriority (uint32_t PriorityGroup, uint32_t PreemptPriority, uint32_t SubPriority)
{
 8009ac0:	b480      	push	{r7}
 8009ac2:	b089      	sub	sp, #36	; 0x24
 8009ac4:	af00      	add	r7, sp, #0
 8009ac6:	60f8      	str	r0, [r7, #12]
 8009ac8:	60b9      	str	r1, [r7, #8]
 8009aca:	607a      	str	r2, [r7, #4]
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
 8009acc:	68fb      	ldr	r3, [r7, #12]
 8009ace:	f003 0307 	and.w	r3, r3, #7
 8009ad2:	61fb      	str	r3, [r7, #28]
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8009ad4:	69fb      	ldr	r3, [r7, #28]
 8009ad6:	f1c3 0307 	rsb	r3, r3, #7
 8009ada:	2b04      	cmp	r3, #4
 8009adc:	bf28      	it	cs
 8009ade:	2304      	movcs	r3, #4
 8009ae0:	61bb      	str	r3, [r7, #24]
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8009ae2:	69fb      	ldr	r3, [r7, #28]
 8009ae4:	3304      	adds	r3, #4
 8009ae6:	2b06      	cmp	r3, #6
 8009ae8:	d902      	bls.n	8009af0 <NVIC_EncodePriority+0x30>
 8009aea:	69fb      	ldr	r3, [r7, #28]
 8009aec:	3b03      	subs	r3, #3
 8009aee:	e000      	b.n	8009af2 <NVIC_EncodePriority+0x32>
 8009af0:	2300      	movs	r3, #0
 8009af2:	617b      	str	r3, [r7, #20]

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8009af4:	f04f 32ff 	mov.w	r2, #4294967295
 8009af8:	69bb      	ldr	r3, [r7, #24]
 8009afa:	fa02 f303 	lsl.w	r3, r2, r3
 8009afe:	43da      	mvns	r2, r3
 8009b00:	68bb      	ldr	r3, [r7, #8]
 8009b02:	401a      	ands	r2, r3
 8009b04:	697b      	ldr	r3, [r7, #20]
 8009b06:	409a      	lsls	r2, r3
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 8009b08:	f04f 31ff 	mov.w	r1, #4294967295
 8009b0c:	697b      	ldr	r3, [r7, #20]
 8009b0e:	fa01 f303 	lsl.w	r3, r1, r3
 8009b12:	43d9      	mvns	r1, r3
 8009b14:	687b      	ldr	r3, [r7, #4]
 8009b16:	400b      	ands	r3, r1
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8009b18:	4313      	orrs	r3, r2
         );
}
 8009b1a:	4618      	mov	r0, r3
 8009b1c:	3724      	adds	r7, #36	; 0x24
 8009b1e:	46bd      	mov	sp, r7
 8009b20:	bc80      	pop	{r7}
 8009b22:	4770      	bx	lr

08009b24 <SysTick_Config>:
  \note    When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
 8009b24:	b580      	push	{r7, lr}
 8009b26:	b082      	sub	sp, #8
 8009b28:	af00      	add	r7, sp, #0
 8009b2a:	6078      	str	r0, [r7, #4]
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8009b2c:	687b      	ldr	r3, [r7, #4]
 8009b2e:	3b01      	subs	r3, #1
 8009b30:	f1b3 7f80 	cmp.w	r3, #16777216	; 0x1000000
 8009b34:	d301      	bcc.n	8009b3a <SysTick_Config+0x16>
  {
    return (1UL);                                                   /* Reload value impossible */
 8009b36:	2301      	movs	r3, #1
 8009b38:	e00f      	b.n	8009b5a <SysTick_Config+0x36>
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 8009b3a:	4a0a      	ldr	r2, [pc, #40]	; (8009b64 <SysTick_Config+0x40>)
 8009b3c:	687b      	ldr	r3, [r7, #4]
 8009b3e:	3b01      	subs	r3, #1
 8009b40:	6053      	str	r3, [r2, #4]
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
 8009b42:	210f      	movs	r1, #15
 8009b44:	f04f 30ff 	mov.w	r0, #4294967295
 8009b48:	f7ff ff90 	bl	8009a6c <__NVIC_SetPriority>
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 8009b4c:	4b05      	ldr	r3, [pc, #20]	; (8009b64 <SysTick_Config+0x40>)
 8009b4e:	2200      	movs	r2, #0
 8009b50:	609a      	str	r2, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 8009b52:	4b04      	ldr	r3, [pc, #16]	; (8009b64 <SysTick_Config+0x40>)
 8009b54:	2207      	movs	r2, #7
 8009b56:	601a      	str	r2, [r3, #0]
                   SysTick_CTRL_TICKINT_Msk   |
                   SysTick_CTRL_ENABLE_Msk;                         /* Enable SysTick IRQ and SysTick Timer */
  return (0UL);                                                     /* Function successful */
 8009b58:	2300      	movs	r3, #0
}
 8009b5a:	4618      	mov	r0, r3
 8009b5c:	3708      	adds	r7, #8
 8009b5e:	46bd      	mov	sp, r7
 8009b60:	bd80      	pop	{r7, pc}
 8009b62:	bf00      	nop
 8009b64:	e000e010 	.word	0xe000e010

08009b68 <HAL_NVIC_SetPriorityGrouping>:
  * @note   When the NVIC_PriorityGroup_0 is selected, IRQ preemption is no more possible. 
  *         The pending IRQ priority will be managed only by the subpriority. 
  * @retval None
  */
void HAL_NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8009b68:	b580      	push	{r7, lr}
 8009b6a:	b082      	sub	sp, #8
 8009b6c:	af00      	add	r7, sp, #0
 8009b6e:	6078      	str	r0, [r7, #4]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));
  
  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
 8009b70:	6878      	ldr	r0, [r7, #4]
 8009b72:	f7ff ff2d 	bl	80099d0 <__NVIC_SetPriorityGrouping>
}
 8009b76:	bf00      	nop
 8009b78:	3708      	adds	r7, #8
 8009b7a:	46bd      	mov	sp, r7
 8009b7c:	bd80      	pop	{r7, pc}

08009b7e <HAL_NVIC_SetPriority>:
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.          
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{ 
 8009b7e:	b580      	push	{r7, lr}
 8009b80:	b086      	sub	sp, #24
 8009b82:	af00      	add	r7, sp, #0
 8009b84:	4603      	mov	r3, r0
 8009b86:	60b9      	str	r1, [r7, #8]
 8009b88:	607a      	str	r2, [r7, #4]
 8009b8a:	73fb      	strb	r3, [r7, #15]
  uint32_t prioritygroup = 0x00U;
 8009b8c:	2300      	movs	r3, #0
 8009b8e:	617b      	str	r3, [r7, #20]
  
  /* Check the parameters */
  assert_param(IS_NVIC_SUB_PRIORITY(SubPriority));
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));
  
  prioritygroup = NVIC_GetPriorityGrouping();
 8009b90:	f7ff ff42 	bl	8009a18 <__NVIC_GetPriorityGrouping>
 8009b94:	6178      	str	r0, [r7, #20]
  
  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
 8009b96:	687a      	ldr	r2, [r7, #4]
 8009b98:	68b9      	ldr	r1, [r7, #8]
 8009b9a:	6978      	ldr	r0, [r7, #20]
 8009b9c:	f7ff ff90 	bl	8009ac0 <NVIC_EncodePriority>
 8009ba0:	4602      	mov	r2, r0
 8009ba2:	f997 300f 	ldrsb.w	r3, [r7, #15]
 8009ba6:	4611      	mov	r1, r2
 8009ba8:	4618      	mov	r0, r3
 8009baa:	f7ff ff5f 	bl	8009a6c <__NVIC_SetPriority>
}
 8009bae:	bf00      	nop
 8009bb0:	3718      	adds	r7, #24
 8009bb2:	46bd      	mov	sp, r7
 8009bb4:	bd80      	pop	{r7, pc}

08009bb6 <HAL_NVIC_EnableIRQ>:
  *         This parameter can be an enumerator of IRQn_Type enumeration
  *         (For the complete STM32 Devices IRQ Channels list, please refer to the appropriate CMSIS device file (stm32f10xxx.h))
  * @retval None
  */
void HAL_NVIC_EnableIRQ(IRQn_Type IRQn)
{
 8009bb6:	b580      	push	{r7, lr}
 8009bb8:	b082      	sub	sp, #8
 8009bba:	af00      	add	r7, sp, #0
 8009bbc:	4603      	mov	r3, r0
 8009bbe:	71fb      	strb	r3, [r7, #7]
  /* Check the parameters */
  assert_param(IS_NVIC_DEVICE_IRQ(IRQn));

  /* Enable interrupt */
  NVIC_EnableIRQ(IRQn);
 8009bc0:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8009bc4:	4618      	mov	r0, r3
 8009bc6:	f7ff ff35 	bl	8009a34 <__NVIC_EnableIRQ>
}
 8009bca:	bf00      	nop
 8009bcc:	3708      	adds	r7, #8
 8009bce:	46bd      	mov	sp, r7
 8009bd0:	bd80      	pop	{r7, pc}

08009bd2 <HAL_SYSTICK_Config>:
  * @param  TicksNumb: Specifies the ticks Number of ticks between two interrupts.
  * @retval status:  - 0  Function succeeded.
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
 8009bd2:	b580      	push	{r7, lr}
 8009bd4:	b082      	sub	sp, #8
 8009bd6:	af00      	add	r7, sp, #0
 8009bd8:	6078      	str	r0, [r7, #4]
   return SysTick_Config(TicksNumb);
 8009bda:	6878      	ldr	r0, [r7, #4]
 8009bdc:	f7ff ffa2 	bl	8009b24 <SysTick_Config>
 8009be0:	4603      	mov	r3, r0
}
 8009be2:	4618      	mov	r0, r3
 8009be4:	3708      	adds	r7, #8
 8009be6:	46bd      	mov	sp, r7
 8009be8:	bd80      	pop	{r7, pc}
	...

08009bec <HAL_GPIO_Init>:
  * @param  GPIO_Init: pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 8009bec:	b480      	push	{r7}
 8009bee:	b08b      	sub	sp, #44	; 0x2c
 8009bf0:	af00      	add	r7, sp, #0
 8009bf2:	6078      	str	r0, [r7, #4]
 8009bf4:	6039      	str	r1, [r7, #0]
  uint32_t position = 0x00u;
 8009bf6:	2300      	movs	r3, #0
 8009bf8:	627b      	str	r3, [r7, #36]	; 0x24
  uint32_t ioposition;
  uint32_t iocurrent;
  uint32_t temp;
  uint32_t config = 0x00u;
 8009bfa:	2300      	movs	r3, #0
 8009bfc:	623b      	str	r3, [r7, #32]
  assert_param(IS_GPIO_ALL_INSTANCE(GPIOx));
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8009bfe:	e127      	b.n	8009e50 <HAL_GPIO_Init+0x264>
  {
    /* Get the IO position */
    ioposition = (0x01uL << position);
 8009c00:	2201      	movs	r2, #1
 8009c02:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009c04:	fa02 f303 	lsl.w	r3, r2, r3
 8009c08:	61fb      	str	r3, [r7, #28]

    /* Get the current IO position */
    iocurrent = (uint32_t)(GPIO_Init->Pin) & ioposition;
 8009c0a:	683b      	ldr	r3, [r7, #0]
 8009c0c:	681b      	ldr	r3, [r3, #0]
 8009c0e:	69fa      	ldr	r2, [r7, #28]
 8009c10:	4013      	ands	r3, r2
 8009c12:	61bb      	str	r3, [r7, #24]

    if (iocurrent == ioposition)
 8009c14:	69ba      	ldr	r2, [r7, #24]
 8009c16:	69fb      	ldr	r3, [r7, #28]
 8009c18:	429a      	cmp	r2, r3
 8009c1a:	f040 8116 	bne.w	8009e4a <HAL_GPIO_Init+0x25e>
    {
      /* Check the Alternate function parameters */
      assert_param(IS_GPIO_AF_INSTANCE(GPIOx));

      /* Based on the required mode, filling config variable with MODEy[1:0] and CNFy[3:2] corresponding bits */
      switch (GPIO_Init->Mode)
 8009c1e:	683b      	ldr	r3, [r7, #0]
 8009c20:	685b      	ldr	r3, [r3, #4]
 8009c22:	2b12      	cmp	r3, #18
 8009c24:	d034      	beq.n	8009c90 <HAL_GPIO_Init+0xa4>
 8009c26:	2b12      	cmp	r3, #18
 8009c28:	d80d      	bhi.n	8009c46 <HAL_GPIO_Init+0x5a>
 8009c2a:	2b02      	cmp	r3, #2
 8009c2c:	d02b      	beq.n	8009c86 <HAL_GPIO_Init+0x9a>
 8009c2e:	2b02      	cmp	r3, #2
 8009c30:	d804      	bhi.n	8009c3c <HAL_GPIO_Init+0x50>
 8009c32:	2b00      	cmp	r3, #0
 8009c34:	d031      	beq.n	8009c9a <HAL_GPIO_Init+0xae>
 8009c36:	2b01      	cmp	r3, #1
 8009c38:	d01c      	beq.n	8009c74 <HAL_GPIO_Init+0x88>
          config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_ANALOG;
          break;

        /* Parameters are checked with assert_param */
        default:
          break;
 8009c3a:	e048      	b.n	8009cce <HAL_GPIO_Init+0xe2>
      switch (GPIO_Init->Mode)
 8009c3c:	2b03      	cmp	r3, #3
 8009c3e:	d043      	beq.n	8009cc8 <HAL_GPIO_Init+0xdc>
 8009c40:	2b11      	cmp	r3, #17
 8009c42:	d01b      	beq.n	8009c7c <HAL_GPIO_Init+0x90>
          break;
 8009c44:	e043      	b.n	8009cce <HAL_GPIO_Init+0xe2>
      switch (GPIO_Init->Mode)
 8009c46:	4a89      	ldr	r2, [pc, #548]	; (8009e6c <HAL_GPIO_Init+0x280>)
 8009c48:	4293      	cmp	r3, r2
 8009c4a:	d026      	beq.n	8009c9a <HAL_GPIO_Init+0xae>
 8009c4c:	4a87      	ldr	r2, [pc, #540]	; (8009e6c <HAL_GPIO_Init+0x280>)
 8009c4e:	4293      	cmp	r3, r2
 8009c50:	d806      	bhi.n	8009c60 <HAL_GPIO_Init+0x74>
 8009c52:	4a87      	ldr	r2, [pc, #540]	; (8009e70 <HAL_GPIO_Init+0x284>)
 8009c54:	4293      	cmp	r3, r2
 8009c56:	d020      	beq.n	8009c9a <HAL_GPIO_Init+0xae>
 8009c58:	4a86      	ldr	r2, [pc, #536]	; (8009e74 <HAL_GPIO_Init+0x288>)
 8009c5a:	4293      	cmp	r3, r2
 8009c5c:	d01d      	beq.n	8009c9a <HAL_GPIO_Init+0xae>
          break;
 8009c5e:	e036      	b.n	8009cce <HAL_GPIO_Init+0xe2>
      switch (GPIO_Init->Mode)
 8009c60:	4a85      	ldr	r2, [pc, #532]	; (8009e78 <HAL_GPIO_Init+0x28c>)
 8009c62:	4293      	cmp	r3, r2
 8009c64:	d019      	beq.n	8009c9a <HAL_GPIO_Init+0xae>
 8009c66:	4a85      	ldr	r2, [pc, #532]	; (8009e7c <HAL_GPIO_Init+0x290>)
 8009c68:	4293      	cmp	r3, r2
 8009c6a:	d016      	beq.n	8009c9a <HAL_GPIO_Init+0xae>
 8009c6c:	4a84      	ldr	r2, [pc, #528]	; (8009e80 <HAL_GPIO_Init+0x294>)
 8009c6e:	4293      	cmp	r3, r2
 8009c70:	d013      	beq.n	8009c9a <HAL_GPIO_Init+0xae>
          break;
 8009c72:	e02c      	b.n	8009cce <HAL_GPIO_Init+0xe2>
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_PP;
 8009c74:	683b      	ldr	r3, [r7, #0]
 8009c76:	68db      	ldr	r3, [r3, #12]
 8009c78:	623b      	str	r3, [r7, #32]
          break;
 8009c7a:	e028      	b.n	8009cce <HAL_GPIO_Init+0xe2>
          config = GPIO_Init->Speed + GPIO_CR_CNF_GP_OUTPUT_OD;
 8009c7c:	683b      	ldr	r3, [r7, #0]
 8009c7e:	68db      	ldr	r3, [r3, #12]
 8009c80:	3304      	adds	r3, #4
 8009c82:	623b      	str	r3, [r7, #32]
          break;
 8009c84:	e023      	b.n	8009cce <HAL_GPIO_Init+0xe2>
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_PP;
 8009c86:	683b      	ldr	r3, [r7, #0]
 8009c88:	68db      	ldr	r3, [r3, #12]
 8009c8a:	3308      	adds	r3, #8
 8009c8c:	623b      	str	r3, [r7, #32]
          break;
 8009c8e:	e01e      	b.n	8009cce <HAL_GPIO_Init+0xe2>
          config = GPIO_Init->Speed + GPIO_CR_CNF_AF_OUTPUT_OD;
 8009c90:	683b      	ldr	r3, [r7, #0]
 8009c92:	68db      	ldr	r3, [r3, #12]
 8009c94:	330c      	adds	r3, #12
 8009c96:	623b      	str	r3, [r7, #32]
          break;
 8009c98:	e019      	b.n	8009cce <HAL_GPIO_Init+0xe2>
          if (GPIO_Init->Pull == GPIO_NOPULL)
 8009c9a:	683b      	ldr	r3, [r7, #0]
 8009c9c:	689b      	ldr	r3, [r3, #8]
 8009c9e:	2b00      	cmp	r3, #0
 8009ca0:	d102      	bne.n	8009ca8 <HAL_GPIO_Init+0xbc>
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_FLOATING;
 8009ca2:	2304      	movs	r3, #4
 8009ca4:	623b      	str	r3, [r7, #32]
          break;
 8009ca6:	e012      	b.n	8009cce <HAL_GPIO_Init+0xe2>
          else if (GPIO_Init->Pull == GPIO_PULLUP)
 8009ca8:	683b      	ldr	r3, [r7, #0]
 8009caa:	689b      	ldr	r3, [r3, #8]
 8009cac:	2b01      	cmp	r3, #1
 8009cae:	d105      	bne.n	8009cbc <HAL_GPIO_Init+0xd0>
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
 8009cb0:	2308      	movs	r3, #8
 8009cb2:	623b      	str	r3, [r7, #32]
            GPIOx->BSRR = ioposition;
 8009cb4:	687b      	ldr	r3, [r7, #4]
 8009cb6:	69fa      	ldr	r2, [r7, #28]
 8009cb8:	611a      	str	r2, [r3, #16]
          break;
 8009cba:	e008      	b.n	8009cce <HAL_GPIO_Init+0xe2>
            config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_INPUT_PU_PD;
 8009cbc:	2308      	movs	r3, #8
 8009cbe:	623b      	str	r3, [r7, #32]
            GPIOx->BRR = ioposition;
 8009cc0:	687b      	ldr	r3, [r7, #4]
 8009cc2:	69fa      	ldr	r2, [r7, #28]
 8009cc4:	615a      	str	r2, [r3, #20]
          break;
 8009cc6:	e002      	b.n	8009cce <HAL_GPIO_Init+0xe2>
          config = GPIO_CR_MODE_INPUT + GPIO_CR_CNF_ANALOG;
 8009cc8:	2300      	movs	r3, #0
 8009cca:	623b      	str	r3, [r7, #32]
          break;
 8009ccc:	bf00      	nop
      }

      /* Check if the current bit belongs to first half or last half of the pin count number
       in order to address CRH or CRL register*/
      configregister = (iocurrent < GPIO_PIN_8) ? &GPIOx->CRL     : &GPIOx->CRH;
 8009cce:	69bb      	ldr	r3, [r7, #24]
 8009cd0:	2bff      	cmp	r3, #255	; 0xff
 8009cd2:	d801      	bhi.n	8009cd8 <HAL_GPIO_Init+0xec>
 8009cd4:	687b      	ldr	r3, [r7, #4]
 8009cd6:	e001      	b.n	8009cdc <HAL_GPIO_Init+0xf0>
 8009cd8:	687b      	ldr	r3, [r7, #4]
 8009cda:	3304      	adds	r3, #4
 8009cdc:	617b      	str	r3, [r7, #20]
      registeroffset = (iocurrent < GPIO_PIN_8) ? (position << 2u) : ((position - 8u) << 2u);
 8009cde:	69bb      	ldr	r3, [r7, #24]
 8009ce0:	2bff      	cmp	r3, #255	; 0xff
 8009ce2:	d802      	bhi.n	8009cea <HAL_GPIO_Init+0xfe>
 8009ce4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009ce6:	009b      	lsls	r3, r3, #2
 8009ce8:	e002      	b.n	8009cf0 <HAL_GPIO_Init+0x104>
 8009cea:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009cec:	3b08      	subs	r3, #8
 8009cee:	009b      	lsls	r3, r3, #2
 8009cf0:	613b      	str	r3, [r7, #16]

      /* Apply the new configuration of the pin to the register */
      MODIFY_REG((*configregister), ((GPIO_CRL_MODE0 | GPIO_CRL_CNF0) << registeroffset), (config << registeroffset));
 8009cf2:	697b      	ldr	r3, [r7, #20]
 8009cf4:	681a      	ldr	r2, [r3, #0]
 8009cf6:	210f      	movs	r1, #15
 8009cf8:	693b      	ldr	r3, [r7, #16]
 8009cfa:	fa01 f303 	lsl.w	r3, r1, r3
 8009cfe:	43db      	mvns	r3, r3
 8009d00:	401a      	ands	r2, r3
 8009d02:	6a39      	ldr	r1, [r7, #32]
 8009d04:	693b      	ldr	r3, [r7, #16]
 8009d06:	fa01 f303 	lsl.w	r3, r1, r3
 8009d0a:	431a      	orrs	r2, r3
 8009d0c:	697b      	ldr	r3, [r7, #20]
 8009d0e:	601a      	str	r2, [r3, #0]

      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if ((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 8009d10:	683b      	ldr	r3, [r7, #0]
 8009d12:	685b      	ldr	r3, [r3, #4]
 8009d14:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8009d18:	2b00      	cmp	r3, #0
 8009d1a:	f000 8096 	beq.w	8009e4a <HAL_GPIO_Init+0x25e>
      {
        /* Enable AFIO Clock */
        __HAL_RCC_AFIO_CLK_ENABLE();
 8009d1e:	4b59      	ldr	r3, [pc, #356]	; (8009e84 <HAL_GPIO_Init+0x298>)
 8009d20:	699b      	ldr	r3, [r3, #24]
 8009d22:	4a58      	ldr	r2, [pc, #352]	; (8009e84 <HAL_GPIO_Init+0x298>)
 8009d24:	f043 0301 	orr.w	r3, r3, #1
 8009d28:	6193      	str	r3, [r2, #24]
 8009d2a:	4b56      	ldr	r3, [pc, #344]	; (8009e84 <HAL_GPIO_Init+0x298>)
 8009d2c:	699b      	ldr	r3, [r3, #24]
 8009d2e:	f003 0301 	and.w	r3, r3, #1
 8009d32:	60bb      	str	r3, [r7, #8]
 8009d34:	68bb      	ldr	r3, [r7, #8]
        temp = AFIO->EXTICR[position >> 2u];
 8009d36:	4a54      	ldr	r2, [pc, #336]	; (8009e88 <HAL_GPIO_Init+0x29c>)
 8009d38:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009d3a:	089b      	lsrs	r3, r3, #2
 8009d3c:	3302      	adds	r3, #2
 8009d3e:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
 8009d42:	60fb      	str	r3, [r7, #12]
        CLEAR_BIT(temp, (0x0Fu) << (4u * (position & 0x03u)));
 8009d44:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009d46:	f003 0303 	and.w	r3, r3, #3
 8009d4a:	009b      	lsls	r3, r3, #2
 8009d4c:	220f      	movs	r2, #15
 8009d4e:	fa02 f303 	lsl.w	r3, r2, r3
 8009d52:	43db      	mvns	r3, r3
 8009d54:	68fa      	ldr	r2, [r7, #12]
 8009d56:	4013      	ands	r3, r2
 8009d58:	60fb      	str	r3, [r7, #12]
        SET_BIT(temp, (GPIO_GET_INDEX(GPIOx)) << (4u * (position & 0x03u)));
 8009d5a:	687b      	ldr	r3, [r7, #4]
 8009d5c:	4a4b      	ldr	r2, [pc, #300]	; (8009e8c <HAL_GPIO_Init+0x2a0>)
 8009d5e:	4293      	cmp	r3, r2
 8009d60:	d013      	beq.n	8009d8a <HAL_GPIO_Init+0x19e>
 8009d62:	687b      	ldr	r3, [r7, #4]
 8009d64:	4a4a      	ldr	r2, [pc, #296]	; (8009e90 <HAL_GPIO_Init+0x2a4>)
 8009d66:	4293      	cmp	r3, r2
 8009d68:	d00d      	beq.n	8009d86 <HAL_GPIO_Init+0x19a>
 8009d6a:	687b      	ldr	r3, [r7, #4]
 8009d6c:	4a49      	ldr	r2, [pc, #292]	; (8009e94 <HAL_GPIO_Init+0x2a8>)
 8009d6e:	4293      	cmp	r3, r2
 8009d70:	d007      	beq.n	8009d82 <HAL_GPIO_Init+0x196>
 8009d72:	687b      	ldr	r3, [r7, #4]
 8009d74:	4a48      	ldr	r2, [pc, #288]	; (8009e98 <HAL_GPIO_Init+0x2ac>)
 8009d76:	4293      	cmp	r3, r2
 8009d78:	d101      	bne.n	8009d7e <HAL_GPIO_Init+0x192>
 8009d7a:	2303      	movs	r3, #3
 8009d7c:	e006      	b.n	8009d8c <HAL_GPIO_Init+0x1a0>
 8009d7e:	2304      	movs	r3, #4
 8009d80:	e004      	b.n	8009d8c <HAL_GPIO_Init+0x1a0>
 8009d82:	2302      	movs	r3, #2
 8009d84:	e002      	b.n	8009d8c <HAL_GPIO_Init+0x1a0>
 8009d86:	2301      	movs	r3, #1
 8009d88:	e000      	b.n	8009d8c <HAL_GPIO_Init+0x1a0>
 8009d8a:	2300      	movs	r3, #0
 8009d8c:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8009d8e:	f002 0203 	and.w	r2, r2, #3
 8009d92:	0092      	lsls	r2, r2, #2
 8009d94:	4093      	lsls	r3, r2
 8009d96:	68fa      	ldr	r2, [r7, #12]
 8009d98:	4313      	orrs	r3, r2
 8009d9a:	60fb      	str	r3, [r7, #12]
        AFIO->EXTICR[position >> 2u] = temp;
 8009d9c:	493a      	ldr	r1, [pc, #232]	; (8009e88 <HAL_GPIO_Init+0x29c>)
 8009d9e:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009da0:	089b      	lsrs	r3, r3, #2
 8009da2:	3302      	adds	r3, #2
 8009da4:	68fa      	ldr	r2, [r7, #12]
 8009da6:	f841 2023 	str.w	r2, [r1, r3, lsl #2]


        /* Configure the interrupt mask */
        if ((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8009daa:	683b      	ldr	r3, [r7, #0]
 8009dac:	685b      	ldr	r3, [r3, #4]
 8009dae:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8009db2:	2b00      	cmp	r3, #0
 8009db4:	d006      	beq.n	8009dc4 <HAL_GPIO_Init+0x1d8>
        {
          SET_BIT(EXTI->IMR, iocurrent);
 8009db6:	4b39      	ldr	r3, [pc, #228]	; (8009e9c <HAL_GPIO_Init+0x2b0>)
 8009db8:	681a      	ldr	r2, [r3, #0]
 8009dba:	4938      	ldr	r1, [pc, #224]	; (8009e9c <HAL_GPIO_Init+0x2b0>)
 8009dbc:	69bb      	ldr	r3, [r7, #24]
 8009dbe:	4313      	orrs	r3, r2
 8009dc0:	600b      	str	r3, [r1, #0]
 8009dc2:	e006      	b.n	8009dd2 <HAL_GPIO_Init+0x1e6>
        }
        else
        {
          CLEAR_BIT(EXTI->IMR, iocurrent);
 8009dc4:	4b35      	ldr	r3, [pc, #212]	; (8009e9c <HAL_GPIO_Init+0x2b0>)
 8009dc6:	681a      	ldr	r2, [r3, #0]
 8009dc8:	69bb      	ldr	r3, [r7, #24]
 8009dca:	43db      	mvns	r3, r3
 8009dcc:	4933      	ldr	r1, [pc, #204]	; (8009e9c <HAL_GPIO_Init+0x2b0>)
 8009dce:	4013      	ands	r3, r2
 8009dd0:	600b      	str	r3, [r1, #0]
        }

        /* Configure the event mask */
        if ((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8009dd2:	683b      	ldr	r3, [r7, #0]
 8009dd4:	685b      	ldr	r3, [r3, #4]
 8009dd6:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8009dda:	2b00      	cmp	r3, #0
 8009ddc:	d006      	beq.n	8009dec <HAL_GPIO_Init+0x200>
        {
          SET_BIT(EXTI->EMR, iocurrent);
 8009dde:	4b2f      	ldr	r3, [pc, #188]	; (8009e9c <HAL_GPIO_Init+0x2b0>)
 8009de0:	685a      	ldr	r2, [r3, #4]
 8009de2:	492e      	ldr	r1, [pc, #184]	; (8009e9c <HAL_GPIO_Init+0x2b0>)
 8009de4:	69bb      	ldr	r3, [r7, #24]
 8009de6:	4313      	orrs	r3, r2
 8009de8:	604b      	str	r3, [r1, #4]
 8009dea:	e006      	b.n	8009dfa <HAL_GPIO_Init+0x20e>
        }
        else
        {
          CLEAR_BIT(EXTI->EMR, iocurrent);
 8009dec:	4b2b      	ldr	r3, [pc, #172]	; (8009e9c <HAL_GPIO_Init+0x2b0>)
 8009dee:	685a      	ldr	r2, [r3, #4]
 8009df0:	69bb      	ldr	r3, [r7, #24]
 8009df2:	43db      	mvns	r3, r3
 8009df4:	4929      	ldr	r1, [pc, #164]	; (8009e9c <HAL_GPIO_Init+0x2b0>)
 8009df6:	4013      	ands	r3, r2
 8009df8:	604b      	str	r3, [r1, #4]
        }

        /* Enable or disable the rising trigger */
        if ((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8009dfa:	683b      	ldr	r3, [r7, #0]
 8009dfc:	685b      	ldr	r3, [r3, #4]
 8009dfe:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8009e02:	2b00      	cmp	r3, #0
 8009e04:	d006      	beq.n	8009e14 <HAL_GPIO_Init+0x228>
        {
          SET_BIT(EXTI->RTSR, iocurrent);
 8009e06:	4b25      	ldr	r3, [pc, #148]	; (8009e9c <HAL_GPIO_Init+0x2b0>)
 8009e08:	689a      	ldr	r2, [r3, #8]
 8009e0a:	4924      	ldr	r1, [pc, #144]	; (8009e9c <HAL_GPIO_Init+0x2b0>)
 8009e0c:	69bb      	ldr	r3, [r7, #24]
 8009e0e:	4313      	orrs	r3, r2
 8009e10:	608b      	str	r3, [r1, #8]
 8009e12:	e006      	b.n	8009e22 <HAL_GPIO_Init+0x236>
        }
        else
        {
          CLEAR_BIT(EXTI->RTSR, iocurrent);
 8009e14:	4b21      	ldr	r3, [pc, #132]	; (8009e9c <HAL_GPIO_Init+0x2b0>)
 8009e16:	689a      	ldr	r2, [r3, #8]
 8009e18:	69bb      	ldr	r3, [r7, #24]
 8009e1a:	43db      	mvns	r3, r3
 8009e1c:	491f      	ldr	r1, [pc, #124]	; (8009e9c <HAL_GPIO_Init+0x2b0>)
 8009e1e:	4013      	ands	r3, r2
 8009e20:	608b      	str	r3, [r1, #8]
        }

        /* Enable or disable the falling trigger */
        if ((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8009e22:	683b      	ldr	r3, [r7, #0]
 8009e24:	685b      	ldr	r3, [r3, #4]
 8009e26:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8009e2a:	2b00      	cmp	r3, #0
 8009e2c:	d006      	beq.n	8009e3c <HAL_GPIO_Init+0x250>
        {
          SET_BIT(EXTI->FTSR, iocurrent);
 8009e2e:	4b1b      	ldr	r3, [pc, #108]	; (8009e9c <HAL_GPIO_Init+0x2b0>)
 8009e30:	68da      	ldr	r2, [r3, #12]
 8009e32:	491a      	ldr	r1, [pc, #104]	; (8009e9c <HAL_GPIO_Init+0x2b0>)
 8009e34:	69bb      	ldr	r3, [r7, #24]
 8009e36:	4313      	orrs	r3, r2
 8009e38:	60cb      	str	r3, [r1, #12]
 8009e3a:	e006      	b.n	8009e4a <HAL_GPIO_Init+0x25e>
        }
        else
        {
          CLEAR_BIT(EXTI->FTSR, iocurrent);
 8009e3c:	4b17      	ldr	r3, [pc, #92]	; (8009e9c <HAL_GPIO_Init+0x2b0>)
 8009e3e:	68da      	ldr	r2, [r3, #12]
 8009e40:	69bb      	ldr	r3, [r7, #24]
 8009e42:	43db      	mvns	r3, r3
 8009e44:	4915      	ldr	r1, [pc, #84]	; (8009e9c <HAL_GPIO_Init+0x2b0>)
 8009e46:	4013      	ands	r3, r2
 8009e48:	60cb      	str	r3, [r1, #12]
        }
      }
    }

	position++;
 8009e4a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009e4c:	3301      	adds	r3, #1
 8009e4e:	627b      	str	r3, [r7, #36]	; 0x24
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8009e50:	683b      	ldr	r3, [r7, #0]
 8009e52:	681a      	ldr	r2, [r3, #0]
 8009e54:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8009e56:	fa22 f303 	lsr.w	r3, r2, r3
 8009e5a:	2b00      	cmp	r3, #0
 8009e5c:	f47f aed0 	bne.w	8009c00 <HAL_GPIO_Init+0x14>
  }
}
 8009e60:	bf00      	nop
 8009e62:	372c      	adds	r7, #44	; 0x2c
 8009e64:	46bd      	mov	sp, r7
 8009e66:	bc80      	pop	{r7}
 8009e68:	4770      	bx	lr
 8009e6a:	bf00      	nop
 8009e6c:	10210000 	.word	0x10210000
 8009e70:	10110000 	.word	0x10110000
 8009e74:	10120000 	.word	0x10120000
 8009e78:	10310000 	.word	0x10310000
 8009e7c:	10320000 	.word	0x10320000
 8009e80:	10220000 	.word	0x10220000
 8009e84:	40021000 	.word	0x40021000
 8009e88:	40010000 	.word	0x40010000
 8009e8c:	40010800 	.word	0x40010800
 8009e90:	40010c00 	.word	0x40010c00
 8009e94:	40011000 	.word	0x40011000
 8009e98:	40011400 	.word	0x40011400
 8009e9c:	40010400 	.word	0x40010400

08009ea0 <HAL_GPIO_WritePin>:
  *            @arg GPIO_PIN_RESET: to clear the port pin
  *            @arg GPIO_PIN_SET: to set the port pin
  * @retval None
  */
void HAL_GPIO_WritePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin, GPIO_PinState PinState)
{
 8009ea0:	b480      	push	{r7}
 8009ea2:	b083      	sub	sp, #12
 8009ea4:	af00      	add	r7, sp, #0
 8009ea6:	6078      	str	r0, [r7, #4]
 8009ea8:	460b      	mov	r3, r1
 8009eaa:	807b      	strh	r3, [r7, #2]
 8009eac:	4613      	mov	r3, r2
 8009eae:	707b      	strb	r3, [r7, #1]
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if (PinState != GPIO_PIN_RESET)
 8009eb0:	787b      	ldrb	r3, [r7, #1]
 8009eb2:	2b00      	cmp	r3, #0
 8009eb4:	d003      	beq.n	8009ebe <HAL_GPIO_WritePin+0x1e>
  {
    GPIOx->BSRR = GPIO_Pin;
 8009eb6:	887a      	ldrh	r2, [r7, #2]
 8009eb8:	687b      	ldr	r3, [r7, #4]
 8009eba:	611a      	str	r2, [r3, #16]
  }
  else
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16u;
  }
}
 8009ebc:	e003      	b.n	8009ec6 <HAL_GPIO_WritePin+0x26>
    GPIOx->BSRR = (uint32_t)GPIO_Pin << 16u;
 8009ebe:	887b      	ldrh	r3, [r7, #2]
 8009ec0:	041a      	lsls	r2, r3, #16
 8009ec2:	687b      	ldr	r3, [r7, #4]
 8009ec4:	611a      	str	r2, [r3, #16]
}
 8009ec6:	bf00      	nop
 8009ec8:	370c      	adds	r7, #12
 8009eca:	46bd      	mov	sp, r7
 8009ecc:	bc80      	pop	{r7}
 8009ece:	4770      	bx	lr

08009ed0 <HAL_GPIO_TogglePin>:
  * @param  GPIOx: where x can be (A..G depending on device used) to select the GPIO peripheral
  * @param  GPIO_Pin: Specifies the pins to be toggled.
  * @retval None
  */
void HAL_GPIO_TogglePin(GPIO_TypeDef *GPIOx, uint16_t GPIO_Pin)
{
 8009ed0:	b480      	push	{r7}
 8009ed2:	b085      	sub	sp, #20
 8009ed4:	af00      	add	r7, sp, #0
 8009ed6:	6078      	str	r0, [r7, #4]
 8009ed8:	460b      	mov	r3, r1
 8009eda:	807b      	strh	r3, [r7, #2]

  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));

  /* get current Ouput Data Register value */
  odr = GPIOx->ODR;
 8009edc:	687b      	ldr	r3, [r7, #4]
 8009ede:	68db      	ldr	r3, [r3, #12]
 8009ee0:	60fb      	str	r3, [r7, #12]

  /* Set selected pins that were at low level, and reset ones that were high */
  GPIOx->BSRR = ((odr & GPIO_Pin) << GPIO_NUMBER) | (~odr & GPIO_Pin);
 8009ee2:	887a      	ldrh	r2, [r7, #2]
 8009ee4:	68fb      	ldr	r3, [r7, #12]
 8009ee6:	4013      	ands	r3, r2
 8009ee8:	041a      	lsls	r2, r3, #16
 8009eea:	68fb      	ldr	r3, [r7, #12]
 8009eec:	43d9      	mvns	r1, r3
 8009eee:	887b      	ldrh	r3, [r7, #2]
 8009ef0:	400b      	ands	r3, r1
 8009ef2:	431a      	orrs	r2, r3
 8009ef4:	687b      	ldr	r3, [r7, #4]
 8009ef6:	611a      	str	r2, [r3, #16]
}
 8009ef8:	bf00      	nop
 8009efa:	3714      	adds	r7, #20
 8009efc:	46bd      	mov	sp, r7
 8009efe:	bc80      	pop	{r7}
 8009f00:	4770      	bx	lr
	...

08009f04 <HAL_GPIO_EXTI_IRQHandler>:
  * @brief  This function handles EXTI interrupt request.
  * @param  GPIO_Pin: Specifies the pins connected EXTI line
  * @retval None
  */
void HAL_GPIO_EXTI_IRQHandler(uint16_t GPIO_Pin)
{
 8009f04:	b580      	push	{r7, lr}
 8009f06:	b082      	sub	sp, #8
 8009f08:	af00      	add	r7, sp, #0
 8009f0a:	4603      	mov	r3, r0
 8009f0c:	80fb      	strh	r3, [r7, #6]
  /* EXTI line interrupt detected */
  if (__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 8009f0e:	4b08      	ldr	r3, [pc, #32]	; (8009f30 <HAL_GPIO_EXTI_IRQHandler+0x2c>)
 8009f10:	695a      	ldr	r2, [r3, #20]
 8009f12:	88fb      	ldrh	r3, [r7, #6]
 8009f14:	4013      	ands	r3, r2
 8009f16:	2b00      	cmp	r3, #0
 8009f18:	d006      	beq.n	8009f28 <HAL_GPIO_EXTI_IRQHandler+0x24>
  {
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 8009f1a:	4a05      	ldr	r2, [pc, #20]	; (8009f30 <HAL_GPIO_EXTI_IRQHandler+0x2c>)
 8009f1c:	88fb      	ldrh	r3, [r7, #6]
 8009f1e:	6153      	str	r3, [r2, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 8009f20:	88fb      	ldrh	r3, [r7, #6]
 8009f22:	4618      	mov	r0, r3
 8009f24:	f7fe fe42 	bl	8008bac <HAL_GPIO_EXTI_Callback>
  }
}
 8009f28:	bf00      	nop
 8009f2a:	3708      	adds	r7, #8
 8009f2c:	46bd      	mov	sp, r7
 8009f2e:	bd80      	pop	{r7, pc}
 8009f30:	40010400 	.word	0x40010400

08009f34 <__libc_init_array>:
 8009f34:	b570      	push	{r4, r5, r6, lr}
 8009f36:	2500      	movs	r5, #0
 8009f38:	4e0c      	ldr	r6, [pc, #48]	; (8009f6c <__libc_init_array+0x38>)
 8009f3a:	4c0d      	ldr	r4, [pc, #52]	; (8009f70 <__libc_init_array+0x3c>)
 8009f3c:	1ba4      	subs	r4, r4, r6
 8009f3e:	10a4      	asrs	r4, r4, #2
 8009f40:	42a5      	cmp	r5, r4
 8009f42:	d109      	bne.n	8009f58 <__libc_init_array+0x24>
 8009f44:	f000 f81a 	bl	8009f7c <_init>
 8009f48:	2500      	movs	r5, #0
 8009f4a:	4e0a      	ldr	r6, [pc, #40]	; (8009f74 <__libc_init_array+0x40>)
 8009f4c:	4c0a      	ldr	r4, [pc, #40]	; (8009f78 <__libc_init_array+0x44>)
 8009f4e:	1ba4      	subs	r4, r4, r6
 8009f50:	10a4      	asrs	r4, r4, #2
 8009f52:	42a5      	cmp	r5, r4
 8009f54:	d105      	bne.n	8009f62 <__libc_init_array+0x2e>
 8009f56:	bd70      	pop	{r4, r5, r6, pc}
 8009f58:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8009f5c:	4798      	blx	r3
 8009f5e:	3501      	adds	r5, #1
 8009f60:	e7ee      	b.n	8009f40 <__libc_init_array+0xc>
 8009f62:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8009f66:	4798      	blx	r3
 8009f68:	3501      	adds	r5, #1
 8009f6a:	e7f2      	b.n	8009f52 <__libc_init_array+0x1e>
 8009f6c:	08009fc4 	.word	0x08009fc4
 8009f70:	08009fc4 	.word	0x08009fc4
 8009f74:	08009fc4 	.word	0x08009fc4
 8009f78:	08009fc8 	.word	0x08009fc8

08009f7c <_init>:
 8009f7c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009f7e:	bf00      	nop
 8009f80:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8009f82:	bc08      	pop	{r3}
 8009f84:	469e      	mov	lr, r3
 8009f86:	4770      	bx	lr

08009f88 <_fini>:
 8009f88:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8009f8a:	bf00      	nop
 8009f8c:	bcf8      	pop	{r3, r4, r5, r6, r7}
 8009f8e:	bc08      	pop	{r3}
 8009f90:	469e      	mov	lr, r3
 8009f92:	4770      	bx	lr
